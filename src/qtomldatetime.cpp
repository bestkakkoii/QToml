/*
 * MIT License
 *
 * Copyright (c) 2025 QToml Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Project Information:
 * - Generated by: Claude 4.0 Sonnet (Anthropic AI) on 2025-08-30
 * - Verified and reviewed by: Bestkakkoii
 * - Original project structure and implementation concepts
 * - Built upon toml++ library (https://github.com/marzer/tomlplusplus)
 * - Qt framework integration and wrapper implementation
 */

 /**
  * @file qtomldatetime.cpp
  * @brief Implementation of the QTomlDateTime class for TOML date/time value handling.
  *
  * This implementation provides comprehensive support for TOML date and time values
  * according to the TOML v1.0.0 specification. It handles three distinct temporal
  * formats: date-only, time-only, and full date-time with timezone support.
  *
  * The implementation is optimized for performance with branch prediction hints
  * and efficient memory management through the PIMPL pattern. It integrates
  * seamlessly with Qt's date/time classes while maintaining TOML specification
  * compliance.
  *
  * Key features implemented:
  * - RFC 3339 compliant date-time parsing and formatting
  * - Support for local dates without timezone information
  * - Support for local times without date information
  * - Comprehensive timezone handling through QTimeZone
  * - Efficient memory management and copy semantics
  * - Qt Meta-Object System integration for QVariant support
  *
  * @note This file uses Qt-specific branch prediction macros (Q_LIKELY) for optimization
  * @note All temporal operations are designed to be thread-safe for read operations
  * @see qtomldatetime.h for the class interface
  * @see qtomldatetime_p.h for private implementation details
  */

#pragma execution_character_set("utf-8")

#include "qtomldatetime.h"
#include "qtomldatetime_p.h"

#include <QMetaType>
#include <QVariant>
#include <QDateTime>
#include <utility>

namespace
{
	/**
	 * @brief Anonymous namespace for module-level initialization and constants.
	 *
	 * This namespace contains static initialization code that registers the
	 * QTomlDateTime type with Qt's Meta-Object System for proper QVariant
	 * integration and signal/slot support.
	 */

	 /**
	  * @brief Meta-type registration for QTomlDateTime in Qt's type system.
	  *
	  * This static initialization registers QTomlDateTime as a meta-type with Qt,
	  * enabling it to be used in QVariant containers, signal/slot connections,
	  * and property systems. The registration occurs during static initialization
	  * before main() is called.
	  *
	  * The registration is essential for:
	  * - QVariant::fromValue() and QVariant::value<QTomlDateTime>() functionality
	  * - Q_PROPERTY declarations in Qt classes
	  * - Signal/slot parameters using QTomlDateTime
	  * - QML integration if needed in the future
	  * - Serialization through Qt's property system
	  *
	  * @note The variable name uses q_toml prefix to avoid naming conflicts
	  * @note The const qualification ensures the registration happens exactly once
	  * @see QMetaType::registerType() for registration details
	  */
	const int q_toml_date_time_metatype_id = qRegisterMetaType<QTomlDateTime>();
}

/**
 * @brief Default constructor creating a null QTomlDateTime instance.
 *
 * Creates a QTomlDateTime object in the null state, representing an absence
 * of temporal data. This is the default state for newly constructed objects
 * and serves as a sentinel value for uninitialized or invalid temporal data.
 *
 * The null state is distinct from invalid date/time values and can be
 * explicitly tested using isNull(). Operations on null objects are safe
 * and well-defined, typically returning default-constructed Qt date/time
 * objects.
 *
 * Implementation details:
 * - Uses std::make_unique for exception-safe construction
 * - Initializes private implementation with null type
 * - No memory allocation beyond the private implementation object
 * - Marked noexcept for optimal performance and exception safety
 *
 * @complexity O(1) - Constant time construction
 * @exception Strong exception safety guarantee through RAII
 *
 * @note The constructor is marked noexcept due to guaranteed success
 * @note Default state can be checked with isNull() method
 *
 * @example
 * @code
 * QTomlDateTime dt;                    // Null state
 * Q_ASSERT(dt.isNull());              // Verify null state
 * Q_ASSERT(!dt.date().isValid());     // No valid date component
 * Q_ASSERT(!dt.time().isValid());     // No valid time component
 * @endcode
 *
 * @see isNull() for null state checking
 * @see QTomlDateTimePrivate::type::null for internal state representation
 */
QTomlDateTime::QTomlDateTime() noexcept
	: d_ptr(std::make_unique<QTomlDateTimePrivate>())
{
}

/**
 * @brief Constructs a QTomlDateTime from a QDate (date-only representation).
 *
 * Creates a QTomlDateTime object representing a local date without time
 * information, conforming to TOML's date-only format. This represents
 * calendar dates like "1979-05-27" without any time component or timezone.
 *
 * The resulting object will contain only date information, with time()
 * returning an invalid QTime and timeZone() returning an invalid QTimeZone.
 * This follows TOML's semantic distinction between dates and date-times.
 *
 * Input validation:
 * - Invalid QDate objects are accepted but result in invalid state
 * - The validity of the input date is preserved in the resulting object
 * - No timezone conversion or assumptions are made
 *
 * @param date The QDate object to store as the date component
 *
 * @complexity O(1) - Constant time construction with simple assignment
 * @exception Strong exception safety guarantee
 *
 * @note Invalid input dates result in invalid QTomlDateTime objects
 * @note No time component is associated with date-only values
 * @note The object type will be date-only, affecting behavior of accessor methods
 *
 * @example
 * @code
 * QDate birthday(1990, 12, 25);      // Christmas 1990
 * QTomlDateTime dt(birthday);
 *
 * Q_ASSERT(!dt.isNull());            // Not null - contains date
 * Q_ASSERT(dt.date() == birthday);   // Date component preserved
 * Q_ASSERT(!dt.time().isValid());    // No time component
 * Q_ASSERT(!dt.timeZone().isValid());// No timezone component
 *
 * // Converting to QDateTime gets UTC midnight
 * QDateTime qtDt = dt.toQDateTime();
 * Q_ASSERT(qtDt.date() == birthday);
 * Q_ASSERT(qtDt.time() == QTime(0, 0));
 * Q_ASSERT(qtDt.timeZone() == QTimeZone::utc());
 * @endcode
 *
 * @see QDate for input date class documentation
 * @see date() for retrieving the date component
 * @see toQDateTime() for conversion to full QDateTime
 */
QTomlDateTime::QTomlDateTime(const QDate& date)
	: d_ptr(std::make_unique<QTomlDateTimePrivate>())
{
	d_ptr->type_ = QTomlDateTimePrivate::type::date;
	d_ptr->date_ = date;
}

/**
 * @brief Constructs a QTomlDateTime from a QTime (time-only representation).
 *
 * Creates a QTomlDateTime object representing a local time without date
 * information, conforming to TOML's time-only format. This represents
 * times of day like "07:32:00" or "12:30:45.123" without any date component
 * or timezone information.
 *
 * The resulting object will contain only time information, with date()
 * returning an invalid QDate and timeZone() returning an invalid QTimeZone.
 * This follows TOML's semantic distinction between times and date-times.
 *
 * Precision handling:
 * - Microsecond precision is preserved if present in the input QTime
 * - Fractional seconds are handled according to QTime's capabilities
 * - No rounding or truncation occurs during construction
 *
 * @param time The QTime object to store as the time component
 *
 * @complexity O(1) - Constant time construction with simple assignment
 * @exception Strong exception safety guarantee
 *
 * @note Invalid input times result in invalid QTomlDateTime objects
 * @note No date component is associated with time-only values
 * @note The object type will be time-only, affecting behavior of accessor methods
 *
 * @example
 * @code
 * QTime lunchTime(12, 30, 0);        // 12:30:00
 * QTomlDateTime dt(lunchTime);
 *
 * Q_ASSERT(!dt.isNull());            // Not null - contains time
 * Q_ASSERT(!dt.date().isValid());    // No date component
 * Q_ASSERT(dt.time() == lunchTime);  // Time component preserved
 * Q_ASSERT(!dt.timeZone().isValid());// No timezone component
 *
 * // Converting to QDateTime results in invalid QDateTime
 * QDateTime qtDt = dt.toQDateTime();
 * Q_ASSERT(!qtDt.isValid());         // No date means invalid QDateTime
 * @endcode
 *
 * @see QTime for input time class documentation
 * @see time() for retrieving the time component
 * @see toQDateTime() for conversion behavior with time-only values
 */
QTomlDateTime::QTomlDateTime(const QTime& time)
	: d_ptr(std::make_unique<QTomlDateTimePrivate>())
{
	d_ptr->type_ = QTomlDateTimePrivate::type::time;
	d_ptr->time_ = time;
}

/**
 * @brief Constructs a QTomlDateTime from a QDateTime (full date-time representation).
 *
 * Creates a QTomlDateTime object representing a complete date-time value with
 * optional timezone information, conforming to TOML's date-time format. This
 * represents complete temporal values like "1979-05-27T07:32:00Z" or
 * "1979-05-27T07:32:00-08:00" with full date, time, and timezone components.
 *
 * Timezone handling:
 * - Timezone information from the QDateTime is preserved exactly
 * - UTC timezone is handled correctly for "Z" suffix in TOML
 * - Local timezone context is maintained if present
 * - Invalid timezones are preserved as-is without conversion
 *
 * Input validation and optimization:
 * - Uses Q_LIKELY branch prediction hint for valid inputs (common case)
 * - Invalid QDateTime objects result in null QTomlDateTime objects
 * - All components (date, time, timezone) are extracted and stored separately
 * - No unnecessary copying or conversion occurs during construction
 *
 * @param datetime The QDateTime object containing full temporal information
 *
 * @complexity O(1) - Constant time construction with component extraction
 * @exception Strong exception safety guarantee
 *
 * @note Invalid input QDateTime objects result in null QTomlDateTime objects
 * @note All temporal components are preserved with full precision
 * @note Branch prediction optimization assumes valid input is the common case
 *
 * @example
 * @code
 * // Create a complete date-time with timezone
 * QDateTime moment = QDateTime::currentDateTime();
 * QTomlDateTime dt(moment);
 *
 * Q_ASSERT(!dt.isNull());                    // Valid construction
 * Q_ASSERT(dt.date() == moment.date());     // Date component preserved
 * Q_ASSERT(dt.time() == moment.time());     // Time component preserved
 * Q_ASSERT(dt.timeZone() == moment.timeZone()); // Timezone preserved
 *
 * // Round-trip conversion should be lossless
 * QDateTime reconstituted = dt.toQDateTime();
 * Q_ASSERT(reconstituted == moment);        // Perfect round-trip
 *
 * // Example with invalid input
 * QDateTime invalid;                         // Default invalid QDateTime
 * QTomlDateTime dtInvalid(invalid);
 * Q_ASSERT(dtInvalid.isNull());             // Results in null state
 * @endcode
 *
 * @see QDateTime for input date-time class documentation
 * @see date(), time(), timeZone() for retrieving individual components
 * @see toQDateTime() for reverse conversion
 * @see isNull() for checking validity after construction
 */
QTomlDateTime::QTomlDateTime(const QDateTime& datetime)
	: d_ptr(std::make_unique<QTomlDateTimePrivate>())
{
	// Use branch prediction optimization - valid datetime is the common case
	if (Q_LIKELY(datetime.isValid()))
	{
		d_ptr->type_ = QTomlDateTimePrivate::type::date_time;
		d_ptr->date_ = datetime.date();
		d_ptr->time_ = datetime.time();
		d_ptr->time_zone_ = datetime.timeZone();
	}
	// If datetime is invalid, d_ptr remains in default null state
}

/**
 * @brief Copy constructor creating a deep copy of another QTomlDateTime.
 *
 * Creates a new QTomlDateTime instance that is an exact copy of the source
 * object, including all temporal components and internal state. The copy
 * is completely independent - modifications to either object will not
 * affect the other.
 *
 * Implementation uses the private implementation's copy constructor through
 * std::make_unique, ensuring all internal state is properly duplicated.
 * This includes the temporal type, date component, time component, and
 * timezone information.
 *
 * Copy semantics:
 * - Deep copy of all temporal data and metadata
 * - Independent memory allocation for the new object
 * - Preservation of exact state including null/invalid conditions
 * - Exception-safe construction through RAII principles
 *
 * @param other The QTomlDateTime object to copy from
 *
 * @complexity O(1) - Constant time with small data copying overhead
 * @exception Strong exception safety guarantee through std::make_unique
 *
 * @note The copy is completely independent of the source object
 * @note All temporal precision and timezone information is preserved
 * @note Uses PIMPL pattern for efficient and safe copying
 *
 * @example
 * @code
 * // Create original with specific date-time
 * QDateTime now = QDateTime::currentDateTime();
 * QTomlDateTime original(now);
 *
 * // Copy constructor
 * QTomlDateTime copy(original);
 *
 * // Verify independence and equality
 * Q_ASSERT(copy.date() == original.date());
 * Q_ASSERT(copy.time() == original.time());
 * Q_ASSERT(copy.timeZone() == original.timeZone());
 * Q_ASSERT(copy.toQDateTime() == original.toQDateTime());
 *
 * // Modifications are independent (if a mutable interface existed)
 * // copy would not affect original and vice versa
 * @endcode
 *
 * @see operator=(const QTomlDateTime&) for copy assignment
 * @see QTomlDateTimePrivate copy constructor for implementation details
 */
QTomlDateTime::QTomlDateTime(const QTomlDateTime& other)
	: d_ptr(std::make_unique<QTomlDateTimePrivate>(*other.d_ptr))
{
}

/**
 * @brief Move constructor for efficient transfer of resources.
 *
 * Creates a new QTomlDateTime instance by taking ownership of another
 * object's resources, leaving the source object in a valid but unspecified
 * state. This avoids unnecessary copying and provides optimal performance
 * for temporary objects and return value optimization.
 *
 * The implementation uses the compiler-generated default move constructor
 * which efficiently transfers the unique_ptr ownership. After the move,
 * the source object's d_ptr will be null, but the object remains in a
 * valid state (equivalent to a default-constructed object).
 *
 * Move semantics guarantee:
 * - O(1) constant time operation
 * - No copying of temporal data
 * - Source object remains valid but unspecified
 * - Exception safety through noexcept specification
 *
 * @param other Rvalue reference to the QTomlDateTime to move from
 *
 * @complexity O(1) - Constant time pointer transfer
 * @exception noexcept guarantee - cannot throw exceptions
 *
 * @note Marked noexcept for optimal performance in containers and algorithms
 * @note Source object remains valid but should not be used after move
 * @note Enables return value optimization and efficient container operations
 *
 * @example
 * @code
 * // Function returning QTomlDateTime by value (move-enabled)
 * QTomlDateTime createCurrentTime() {
 *     return QTomlDateTime(QDateTime::currentDateTime());
 * } // Move constructor called implicitly
 *
 * // Explicit move
 * QTomlDateTime original(QDate::currentDate());
 * QTomlDateTime moved = std::move(original);
 *
 * // moved now contains the data, original is valid but unspecified
 * Q_ASSERT(!moved.isNull());
 * // Don't use original after move - state is unspecified
 * @endcode
 *
 * @see operator=(QTomlDateTime&&) for move assignment
 * @see std::unique_ptr move semantics for implementation details
 */
QTomlDateTime::QTomlDateTime(QTomlDateTime&& other) noexcept = default;

/**
 * @brief Destructor ensuring proper cleanup of resources.
 *
 * Automatically releases all resources associated with the QTomlDateTime
 * object through RAII principles. The std::unique_ptr automatically handles
 * destruction of the private implementation, ensuring no memory leaks or
 * resource leaks occur.
 *
 * Cleanup process:
 * - Private implementation is automatically destroyed
 * - All temporal data is released
 * - No manual cleanup required
 * - Exception safety guaranteed
 *
 * @complexity O(1) - Constant time cleanup
 * @exception noexcept guarantee - destruction cannot fail
 *
 * @note Marked noexcept for exception safety guarantees
 * @note Uses RAII through std::unique_ptr for automatic cleanup
 * @note No manual resource management required
 *
 * @see std::unique_ptr destruction for implementation details
 * @see QTomlDateTimePrivate destructor for private implementation cleanup
 */
QTomlDateTime::~QTomlDateTime() noexcept = default;

/**
 * @brief Copy assignment operator for replacing object contents.
 *
 * Replaces the contents of this QTomlDateTime with a copy of another
 * object's data. The operation includes self-assignment protection and
 * ensures that all temporal components are properly copied.
 *
 * Assignment process:
 * - Self-assignment check prevents unnecessary work and potential issues
 * - Deep copy of all temporal data through private implementation
 * - Atomic replacement ensures consistent state during assignment
 * - Exception safety through existing object state preservation
 *
 * Self-assignment safety:
 * The explicit check for self-assignment (this != &other) prevents
 * unnecessary work and potential issues that could arise from an object
 * assigning to itself. This is particularly important for complex objects
 * with custom resource management.
 *
 * @param other The QTomlDateTime object to copy from
 * @return Reference to this object for chaining assignments
 *
 * @complexity O(1) - Constant time with small copying overhead
 * @exception Strong exception safety guarantee
 *
 * @note Self-assignment is handled safely and efficiently
 * @note All temporal precision and state is preserved in the copy
 * @note Supports assignment chaining through reference return
 *
 * @example
 * @code
 * QTomlDateTime dt1(QDate::currentDate());
 * QTomlDateTime dt2(QTime::currentTime());
 * QTomlDateTime dt3;
 *
 * // Assignment chain
 * dt3 = dt2 = dt1;
 * Q_ASSERT(dt3.date() == dt1.date());
 * Q_ASSERT(dt2.date() == dt1.date());
 *
 * // Self-assignment safety
 * dt1 = dt1;  // Safe, no-op due to self-assignment check
 * Q_ASSERT(dt1.date() == QDate::currentDate());
 * @endcode
 *
 * @see operator=(QTomlDateTime&&) for move assignment
 * @see QTomlDateTimePrivate::operator= for implementation details
 */
QTomlDateTime& QTomlDateTime::operator=(const QTomlDateTime& other)
{
	if (this != &other)
	{
		*this->d_ptr = *other.d_ptr;
	}
	return *this;
}

/**
 * @brief Move assignment operator for efficient resource transfer.
 *
 * Replaces the contents of this QTomlDateTime by taking ownership of
 * another object's resources. This provides optimal performance by
 * avoiding unnecessary copying, especially useful for temporary objects
 * and container operations.
 *
 * The implementation uses the compiler-generated default move assignment
 * which efficiently transfers the unique_ptr ownership. The previous
 * contents of this object are automatically cleaned up, and the source
 * object's resources are transferred.
 *
 * Move assignment characteristics:
 * - O(1) constant time operation
 * - Automatic cleanup of previous contents
 * - Transfer of ownership from source object
 * - Source object left in valid but unspecified state
 *
 * @param other Rvalue reference to the QTomlDateTime to move from
 * @return Reference to this object for chaining assignments
 *
 * @complexity O(1) - Constant time resource transfer
 * @exception noexcept guarantee - cannot throw exceptions
 *
 * @note Marked noexcept for optimal performance and exception safety
 * @note Previous contents are automatically cleaned up
 * @note Source object should not be used after the move
 *
 * @example
 * @code
 * QTomlDateTime dt1(QDate::currentDate());
 * QTomlDateTime dt2;
 *
 * // Move assignment
 * dt2 = std::move(dt1);
 * Q_ASSERT(!dt2.isNull());
 * // dt1 is now in valid but unspecified state
 *
 * // Chain assignment with temporary
 * QTomlDateTime dt3;
 * dt3 = QTomlDateTime(QDateTime::currentDateTime());
 * // Move assignment from temporary object
 * @endcode
 *
 * @see operator=(const QTomlDateTime&) for copy assignment
 * @see std::unique_ptr move assignment for implementation details
 */
QTomlDateTime& QTomlDateTime::operator=(QTomlDateTime&& other) noexcept = default;

/**
 * @brief Checks if the QTomlDateTime object is in a null state.
 *
 * Determines whether this QTomlDateTime object represents a null/empty
 * temporal value, as distinct from an invalid date or time. The null state
 * indicates that no temporal information has been assigned to this object,
 * either through default construction or explicit reset.
 *
 * Null state semantics:
 * - Default-constructed objects are in null state
 * - Objects constructed with invalid QDate/QTime/QDateTime may or may not be null
 * - Null objects return invalid values from all accessor methods
 * - Null state is distinct from having invalid but non-null temporal data
 *
 * Performance optimization:
 * Uses simple type comparison against the null enum value, providing
 * constant-time checking with no computational overhead.
 *
 * @return true if the object is in null state, false otherwise
 *
 * @complexity O(1) - Constant time type check
 * @exception noexcept guarantee - cannot throw exceptions
 *
 * @note Marked noexcept as it performs only simple enum comparison
 * @note Null state is different from invalid temporal values
 * @note Null objects are safe to use but contain no meaningful temporal data
 *
 * @example
 * @code
 * // Default constructor creates null object
 * QTomlDateTime dt1;
 * Q_ASSERT(dt1.isNull());                    // True - default null state
 *
 * // Valid construction is not null
 * QTomlDateTime dt2(QDate::currentDate());
 * Q_ASSERT(!dt2.isNull());                   // False - contains date
 *
 * // Invalid input behavior
 * QTomlDateTime dt3(QDate());                // Invalid QDate
 * Q_ASSERT(!dt3.isNull());                   // False - not null, just invalid
 * Q_ASSERT(!dt3.date().isValid());           // But date is invalid
 *
 * // Checking before use
 * if (!dt1.isNull()) {
 *     QDateTime result = dt1.toQDateTime();  // Safe to convert
 * }
 * @endcode
 *
 * @see QTomlDateTimePrivate::type::null for internal representation
 * @see date(), time(), timeZone() for accessor behavior with null objects
 * @see toQDateTime() for conversion behavior with null objects
 */
bool QTomlDateTime::isNull() const noexcept
{
	return d_ptr->type_ == QTomlDateTimePrivate::type::null;
}

/**
 * @brief Retrieves the date component of the temporal value.
 *
 * Returns the date portion of this QTomlDateTime object if it contains
 * date information (either date-only or full date-time). For time-only
 * or null objects, returns an invalid QDate object.
 *
 * Return behavior by object type:
 * - Date-only objects: Returns the stored date
 * - Date-time objects: Returns the date component
 * - Time-only objects: Returns invalid QDate()
 * - Null objects: Returns invalid QDate()
 *
 * Performance optimization:
 * Uses Q_LIKELY branch prediction hint assuming that date queries on
 * date-containing objects are the common case, optimizing for the
 * typical usage pattern where date() is called on appropriate objects.
 *
 * @return QDate containing the date component, or invalid QDate if none exists
 *
 * @complexity O(1) - Constant time type check and data access
 * @exception noexcept guarantee - cannot throw exceptions
 *
 * @note Uses branch prediction optimization for performance
 * @note Returns invalid QDate for time-only and null objects
 * @note No data conversion or computation occurs
 *
 * @example
 * @code
 * // Date-only object
 * QDate today = QDate::currentDate();
 * QTomlDateTime dt1(today);
 * Q_ASSERT(dt1.date() == today);             // Returns stored date
 * Q_ASSERT(dt1.date().isValid());            // Date is valid
 *
 * // Date-time object
 * QDateTime now = QDateTime::currentDateTime();
 * QTomlDateTime dt2(now);
 * Q_ASSERT(dt2.date() == now.date());        // Returns date component
 *
 * // Time-only object
 * QTomlDateTime dt3(QTime::currentTime());
 * Q_ASSERT(!dt3.date().isValid());           // No date component
 *
 * // Null object
 * QTomlDateTime dt4;
 * Q_ASSERT(!dt4.date().isValid());           // Null has no date
 *
 * // Safe usage pattern
 * if (dt1.date().isValid()) {
 *     int year = dt1.date().year();          // Safe to use date methods
 * }
 * @endcode
 *
 * @see time() for retrieving time component
 * @see timeZone() for retrieving timezone component
 * @see toQDateTime() for complete temporal reconstruction
 * @see QDate::isValid() for checking return value validity
 */
QDate QTomlDateTime::date() const noexcept
{
	// Branch prediction: assume date queries on date-containing objects are common
	if (Q_LIKELY(d_ptr->type_ == QTomlDateTimePrivate::type::date ||
		d_ptr->type_ == QTomlDateTimePrivate::type::date_time))
	{
		return d_ptr->date_;
	}
	return QDate();  // Invalid QDate for time-only and null objects
}

/**
 * @brief Retrieves the time component of the temporal value.
 *
 * Returns the time portion of this QTomlDateTime object if it contains
 * time information (either time-only or full date-time). For date-only
 * or null objects, returns an invalid QTime object.
 *
 * Return behavior by object type:
 * - Time-only objects: Returns the stored time
 * - Date-time objects: Returns the time component
 * - Date-only objects: Returns invalid QTime()
 * - Null objects: Returns invalid QTime()
 *
 * Precision preservation:
 * All time precision from the original QTime is preserved, including
 * milliseconds and microseconds if they were present in the source data.
 * No rounding or truncation occurs during retrieval.
 *
 * Performance optimization:
 * Uses Q_LIKELY branch prediction hint for the common case where time()
 * is called on objects that actually contain time information.
 *
 * @return QTime containing the time component, or invalid QTime if none exists
 *
 * @complexity O(1) - Constant time type check and data access
 * @exception noexcept guarantee - cannot throw exceptions
 *
 * @note Uses branch prediction optimization for performance
 * @note Returns invalid QTime for date-only and null objects
 * @note All original time precision is preserved
 *
 * @example
 * @code
 * // Time-only object
 * QTime lunchTime(12, 30, 45, 123);          // With milliseconds
 * QTomlDateTime dt1(lunchTime);
 * Q_ASSERT(dt1.time() == lunchTime);         // Full precision preserved
 * Q_ASSERT(dt1.time().msec() == 123);        // Milliseconds intact
 *
 * // Date-time object
 * QDateTime now = QDateTime::currentDateTime();
 * QTomlDateTime dt2(now);
 * Q_ASSERT(dt2.time() == now.time());        // Time component extracted
 *
 * // Date-only object
 * QTomlDateTime dt3(QDate::currentDate());
 * Q_ASSERT(!dt3.time().isValid());           // No time component
 *
 * // Null object
 * QTomlDateTime dt4;
 * Q_ASSERT(!dt4.time().isValid());           // Null has no time
 *
 * // Working with time precision
 * if (dt1.time().isValid()) {
 *     int hour = dt1.time().hour();
 *     int minute = dt1.time().minute();
 *     int second = dt1.time().second();
 *     int msec = dt1.time().msec();           // All precision available
 * }
 * @endcode
 *
 * @see date() for retrieving date component
 * @see timeZone() for retrieving timezone component
 * @see toQDateTime() for complete temporal reconstruction
 * @see QTime::isValid() for checking return value validity
 */
QTime QTomlDateTime::time() const noexcept
{
	// Branch prediction: assume time queries on time-containing objects are common
	if (Q_LIKELY(d_ptr->type_ == QTomlDateTimePrivate::type::time ||
		d_ptr->type_ == QTomlDateTimePrivate::type::date_time))
	{
		return d_ptr->time_;
	}
	return QTime();  // Invalid QTime for date-only and null objects
}

/**
 * @brief Retrieves the timezone component of the temporal value.
 *
 * Returns the timezone information of this QTomlDateTime object if it
 * represents a full date-time value with timezone data. For all other
 * object types (date-only, time-only, or null), returns an invalid
 * QTimeZone object.
 *
 * Return behavior by object type:
 * - Date-time objects: Returns the stored timezone (may be UTC, local, or offset)
 * - Date-only objects: Returns invalid QTimeZone() (dates have no timezone concept)
 * - Time-only objects: Returns invalid QTimeZone() (times have no timezone concept)
 * - Null objects: Returns invalid QTimeZone()
 *
 * Timezone types supported:
 * - UTC timezone for "Z" suffix in TOML date-times
 * - Fixed offset timezones for "+05:00" style suffixes
 * - Named timezones if supported by the system
 * - Local timezone context when no explicit timezone is specified
 *
 * Performance optimization:
 * Uses Q_LIKELY branch prediction hint optimizing for the case where
 * timeZone() is called on actual date-time objects that contain timezone data.
 *
 * @return QTimeZone containing timezone information, or invalid QTimeZone if none exists
 *
 * @complexity O(1) - Constant time type check and data access
 * @exception noexcept guarantee - cannot throw exceptions
 *
 * @note Only date-time objects can have timezone information
 * @note Uses branch prediction optimization for performance
 * @note Returns invalid QTimeZone for non-date-time objects
 *
 * @example
 * @code
 * // Date-time with UTC timezone
 * QDateTime utcTime = QDateTime::currentDateTimeUtc();
 * QTomlDateTime dt1(utcTime);
 * Q_ASSERT(dt1.timeZone().isValid());        // Has timezone
 * Q_ASSERT(dt1.timeZone() == QTimeZone::utc()); // UTC timezone
 *
 * // Date-time with system timezone
 * QDateTime localTime = QDateTime::currentDateTime();
 * QTomlDateTime dt2(localTime);
 * Q_ASSERT(dt2.timeZone().isValid());        // Has timezone
 * Q_ASSERT(dt2.timeZone() == QTimeZone::systemTimeZone());
 *
 * // Date-only object (no timezone concept)
 * QTomlDateTime dt3(QDate::currentDate());
 * Q_ASSERT(!dt3.timeZone().isValid());       // No timezone for dates
 *
 * // Time-only object (no timezone concept)
 * QTomlDateTime dt4(QTime::currentTime());
 * Q_ASSERT(!dt4.timeZone().isValid());       // No timezone for times
 *
 * // Working with timezone information
 * if (dt1.timeZone().isValid()) {
 *     QString tzName = dt1.timeZone().id();   // Get timezone identifier
 *     int offsetSeconds = dt1.timeZone().offsetFromUtc(dt1.toQDateTime());
 * }
 * @endcode
 *
 * @see date() for retrieving date component
 * @see time() for retrieving time component
 * @see toQDateTime() for complete temporal reconstruction with timezone
 * @see QTimeZone::isValid() for checking return value validity
 */
QTimeZone QTomlDateTime::timeZone() const noexcept
{
	// Branch prediction: assume timezone queries on date-time objects are common
	if (Q_LIKELY(d_ptr->type_ == QTomlDateTimePrivate::type::date_time))
	{
		return d_ptr->time_zone_;
	}
	return QTimeZone();  // Invalid QTimeZone for non-date-time objects
}

/**
 * @brief Converts the QTomlDateTime to a QDateTime object.
 *
 * Reconstructs a complete QDateTime object from the stored temporal components,
 * with behavior depending on the type of temporal data stored in this object.
 * This method provides the primary interface for integrating with Qt's
 * date-time system and other Qt APIs that expect QDateTime objects.
 *
 * Conversion behavior by object type:
 * - Date-time objects: Complete reconstruction with all components
 * - Date-only objects: Date at midnight UTC (00:00:00Z)
 * - Time-only objects: Invalid QDateTime (time without date is meaningless)
 * - Null objects: Invalid QDateTime
 *
 * Timezone handling:
 * For date-time objects, the original timezone is preserved exactly.
 * For date-only objects, UTC is used as the timezone with midnight as
 * the time, following TOML conventions for date-only values.
 *
 * Data preservation:
 * All precision from the original temporal components is maintained in
 * the resulting QDateTime, including microsecond precision for times
 * and exact timezone information for date-times.
 *
 * @return QDateTime object with reconstructed temporal data, or invalid QDateTime
 *
 * @complexity O(1) - Constant time component assembly
 * @exception noexcept guarantee - cannot throw exceptions
 *
 * @note Date-only values are converted to midnight UTC
 * @note Time-only values result in invalid QDateTime
 * @note All original precision and timezone information is preserved
 * @note The result may be invalid for time-only and null objects
 *
 * @example
 * @code
 * // Date-time conversion (lossless round-trip)
 * QDateTime original = QDateTime::currentDateTime();
 * QTomlDateTime dt1(original);
 * QDateTime reconstructed = dt1.toQDateTime();
 * Q_ASSERT(reconstructed == original);       // Perfect round-trip
 *
 * // Date-only conversion (becomes midnight UTC)
 * QDate today = QDate::currentDate();
 * QTomlDateTime dt2(today);
 * QDateTime result = dt2.toQDateTime();
 * Q_ASSERT(result.isValid());                // Valid result
 * Q_ASSERT(result.date() == today);          // Date preserved
 * Q_ASSERT(result.time() == QTime(0, 0));    // Midnight time
 * Q_ASSERT(result.timeZone() == QTimeZone::utc()); // UTC timezone
 *
 * // Time-only conversion (invalid result)
 * QTime noon(12, 0);
 * QTomlDateTime dt3(noon);
 * QDateTime timeResult = dt3.toQDateTime();
 * Q_ASSERT(!timeResult.isValid());           // Invalid - no date
 *
 * // Null conversion (invalid result)
 * QTomlDateTime dt4;
 * QDateTime nullResult = dt4.toQDateTime();
 * Q_ASSERT(!nullResult.isValid());           // Invalid - null object
 *
 * // Safe usage pattern
 * QDateTime converted = dt1.toQDateTime();
 * if (converted.isValid()) {
 *     // Safe to use converted QDateTime
 *     QString iso = converted.toString(Qt::ISODate);
 * }
 * @endcode
 *
 * @see date() for date component access
 * @see time() for time component access
 * @see timeZone() for timezone component access
 * @see QDateTime::isValid() for checking result validity
 * @see QDateTime constructor overloads for reconstruction details
 */
QDateTime QTomlDateTime::toQDateTime() const noexcept
{
	switch (d_ptr->type_)
	{
	case QTomlDateTimePrivate::type::date_time:
		// Complete date-time: reconstruct with all components
		return QDateTime(d_ptr->date_, d_ptr->time_, d_ptr->time_zone_);

	case QTomlDateTimePrivate::type::date:
		// Date-only: use midnight UTC as per TOML conventions
		return QDateTime(d_ptr->date_, QTime(0, 0), QTimeZone::utc());

	case QTomlDateTimePrivate::type::time:
	case QTomlDateTimePrivate::type::null:
	default:
		// Time-only and null: invalid QDateTime (no meaningful conversion)
		return QDateTime();
	}
}