/*
 * MIT License
 *
 * Copyright (c) 2025 QToml Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Project Information:
 * - Generated by: Claude 4.0 Sonnet (Anthropic AI) on 2025-08-30
 * - Verified and reviewed by: Bestkakkoii
 * - Original project structure and implementation concepts
 * - Built upon toml++ library (https://github.com/marzer/tomlplusplus)
 * - Qt framework integration and wrapper implementation
 */

 /**
  * @file qtomlvalue.cpp
  * @brief Implementation of QTomlValue class providing unified TOML value representation.
  *
  * This file contains the complete implementation of the QTomlValue class, which implements
  * the Variant Pattern to represent all TOML data types in a type-safe, efficient manner.
  * The implementation uses modern C++17 std::variant internally combined with the PIMPL
  * pattern for optimal performance and binary compatibility.
  *
  * Key implementation features:
  * - Type-safe value storage using std::variant with all TOML types
  * - PIMPL pattern for binary compatibility and implementation hiding
  * - Comprehensive constructor overloads for all supported types
  * - Move semantics throughout for optimal resource management
  * - Efficient type conversion methods with implicit conversions where safe
  * - Qt meta-type registration for QVariant and signal/slot integration
  * - Exception-safe operations with strong guarantees
  * - Zero-overhead abstractions for primitive types
  *
  * Supported TOML types and their mappings:
  * - **Null/Undefined**: std::monostate (zero storage cost)
  * - **Bool**: C++ bool for true/false values
  * - **Integer**: qint64 for 64-bit signed integers
  * - **Double**: C++ double for IEEE 754 floating-point
  * - **String**: QString for UTF-8 text with Unicode support
  * - **DateTime**: QTomlDateTime for RFC 3339 compliant timestamps
  * - **Array**: QTomlArray for ordered, heterogeneous collections
  * - **Object**: QTomlObject for unordered key-value mappings
  *
  * Performance characteristics:
  * - Storage size equals largest contained type plus discriminator
  * - Type queries are O(1) operations through cached type information
  * - Value access is O(1) with compile-time type checking
  * - Copy/move operations depend on contained type
  * - No dynamic allocation for primitive types
  * - std::variant provides exception-safe type switching
  *
  * The implementation is organized into sections:
  * - Meta-type registration for Qt integration
  * - Construction with type-specific initialization
  * - Copy and move semantics with optimal resource management
  * - Type checking methods for runtime type identification
  * - Type conversion methods with safe implicit conversions
  * - Utility methods for object management
  *
  * Thread safety:
  * - Read operations are thread-safe when no modifications occur
  * - Write operations require external synchronization
  * - Copy construction is thread-safe with proper synchronization
  * - std::variant operations provide strong exception safety
  *
  * @note This file uses modern C++17 features (std::variant, constexpr if)
  * @note All operations preserve TOML specification compliance
  * @note The variant approach eliminates runtime type errors
  * @see qtomlvalue.h for the public interface
  * @see qtomlvalue_p.h for private implementation details
  */

#pragma execution_character_set("utf-8")

#include "qtomlvalue.h"
#include "qtomlvalue_p.h"
#include "qtomlarray.h"
#include "qtomlobject.h"
#include "qtomldatetime.h"

#include <QMetaType>
#include <limits>
#include <utility>
#include <variant>

namespace
{
	/**
	 * @brief Global meta-type registration for QTomlValue.
	 *
	 * Ensures that QTomlValue is registered with Qt's meta-object system during
	 * static initialization. This registration enables comprehensive Qt framework
	 * integration including:
	 * - QVariant storage and conversion
	 * - Signal and slot parameter passing
	 * - Property system integration
	 * - QML type support and automatic conversions
	 * - Debug stream operations
	 * - Serialization through Qt's property system
	 *
	 * The registration occurs automatically during program startup as part of
	 * static initialization, ensuring the type is available throughout the
	 * program's lifetime without manual intervention.
	 *
	 * @note Registration is performed once per program execution
	 * @note Essential for full Qt framework integration
	 * @note Enables type-safe QVariant operations and conversions
	 * @see Q_DECLARE_METATYPE for type registration requirements
	 * @see qRegisterMetaType for registration function details
	 */
	const int q_toml_value_metatype_id = qRegisterMetaType<QTomlValue>();
}

/**
 * @brief Type constructor creating value of specified type with default content.
 *
 * Creates a QTomlValue of the specified type with appropriate default content.
 * Each type is initialized with sensible defaults according to TOML semantics
 * and C++ best practices.
 *
 * Default value initialization by type:
 * - **Null/Undefined**: std::monostate (represents absence of value)
 * - **Bool**: false (TOML boolean default)
 * - **Integer**: 0 (zero value)
 * - **Double**: 0.0 (zero floating-point value)
 * - **String**: Empty QString (no text content)
 * - **DateTime**: Empty QTomlDateTime (invalid date-time)
 * - **Array**: Empty QTomlArray (no elements)
 * - **Object**: Empty QTomlObject (no key-value pairs)
 *
 * @param type The QTomlValue::Type to create, defaults to Null
 *
 * @complexity O(1) - Constant time for all types
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal performance
 * @note All defaults are sensible and type-appropriate
 * @note Container types (Array, Object) are immediately usable
 *
 * @example
 * @code
 * QTomlValue nullValue;                           // Default: Null type
 * QTomlValue boolValue(QTomlValue::Bool);         // false
 * QTomlValue intValue(QTomlValue::Integer);       // 0
 * QTomlValue arrayValue(QTomlValue::Array);       // Empty array
 *
 * Q_ASSERT(nullValue.isNull());
 * Q_ASSERT(boolValue.toBool() == false);
 * Q_ASSERT(arrayValue.toArray().isEmpty());
 * @endcode
 */
QTomlValue::QTomlValue(Type type) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = type;
	switch (type)
	{
	case Bool:     d_ptr->value_.emplace<bool>(false);        break;
	case Integer:  d_ptr->value_.emplace<qint64>(0);          break;
	case Double:   d_ptr->value_.emplace<double>(0.0);        break;
	case String:   d_ptr->value_.emplace<QString>();          break;
	case DateTime: d_ptr->value_.emplace<QTomlDateTime>();    break;
	case Array:    d_ptr->value_.emplace<QTomlArray>();       break;
	case Object:     d_ptr->value_.emplace<QTomlObject>();        break;
	case Null:
	case Undefined:
	default:       d_ptr->value_.emplace<std::monostate>();   break;
	}
}

/**
 * @brief Boolean constructor creating value from bool.
 *
 * Creates a QTomlValue containing the specified boolean value.
 * TOML boolean values are represented as true or false (lowercase).
 *
 * @param b The boolean value to store
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal performance
 * @note Direct storage without conversion overhead
 *
 * @example
 * @code
 * QTomlValue trueValue(true);
 * QTomlValue falseValue(false);
 * Q_ASSERT(trueValue.toBool() == true);
 * Q_ASSERT(falseValue.isBool());
 * @endcode
 */
QTomlValue::QTomlValue(bool b) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Bool;
	d_ptr->value_ = b;
}

/**
 * @brief 32-bit integer constructor with automatic promotion.
 *
 * Creates a QTomlValue from a 32-bit integer, automatically promoting
 * to 64-bit storage to ensure no precision loss and consistency with
 * TOML's integer precision requirements.
 *
 * @param v The 32-bit integer value to store
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal performance
 * @note Automatically promoted to qint64 for consistency
 * @note No precision loss during promotion
 *
 * @example
 * @code
 * QTomlValue value(42);                   // int promoted to qint64
 * Q_ASSERT(value.isInteger());
 * Q_ASSERT(value.toInteger() == 42);
 * @endcode
 */
QTomlValue::QTomlValue(int v) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Integer;
	d_ptr->value_ = static_cast<qint64>(v);
}

/**
 * @brief 64-bit integer constructor for full-precision storage.
 *
 * Creates a QTomlValue containing a 64-bit signed integer value.
 * This matches TOML's recommended integer precision and provides
 * sufficient range for most use cases.
 *
 * @param v The 64-bit integer value to store
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal performance
 * @note Direct storage without conversion
 * @note Preferred constructor for integer values
 *
 * @example
 * @code
 * QTomlValue bigValue(9223372036854775807LL); // Max qint64
 * Q_ASSERT(bigValue.isInteger());
 * Q_ASSERT(bigValue.toInteger() == 9223372036854775807LL);
 * @endcode
 */
QTomlValue::QTomlValue(qint64 v) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Integer;
	d_ptr->value_ = v;
}

/**
 * @brief Double-precision floating-point constructor.
 *
 * Creates a QTomlValue containing a double-precision floating-point number.
 * Supports all legal IEEE 754 values including positive/negative infinity
 * and NaN (Not-a-Number) as per TOML specification.
 *
 * @param v The double-precision floating-point value to store
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal performance
 * @note Supports special values (inf, -inf, nan)
 * @note Direct storage with full precision preservation
 *
 * @example
 * @code
 * QTomlValue piValue(3.14159265359);
 * QTomlValue infValue(std::numeric_limits<double>::infinity());
 * Q_ASSERT(piValue.isDouble());
 * Q_ASSERT(std::isinf(infValue.toDouble()));
 * @endcode
 */
QTomlValue::QTomlValue(double v) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Double;
	d_ptr->value_ = v;
}

/**
 * @brief C-style string constructor with UTF-8 conversion.
 *
 * Creates a QTomlValue from a C-style null-terminated string.
 * The string is automatically converted to UTF-8 encoded QString
 * for proper Unicode handling and Qt integration.
 *
 * @param s Pointer to null-terminated C-style string
 *
 * @complexity O(n) where n is the string length
 * @exception Strong exception safety guarantee
 *
 * @note Handles nullptr input safely (creates empty string)
 * @note Automatic UTF-8 conversion for Unicode support
 * @note String content is copied for safety
 *
 * @example
 * @code
 * QTomlValue value("Hello, TOML!");
 * Q_ASSERT(value.isString());
 * Q_ASSERT(value.toString() == "Hello, TOML!");
 *
 * QTomlValue empty(nullptr);              // Safe handling
 * Q_ASSERT(empty.toString().isEmpty());
 * @endcode
 */
QTomlValue::QTomlValue(const char* s)
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = String;
	d_ptr->value_ = QString::fromUtf8(s);
}

/**
 * @brief QString constructor with copy semantics.
 *
 * Creates a QTomlValue from a QString object using copy semantics.
 * The string content is copied, ensuring the original string remains
 * unchanged and can be safely modified after construction.
 *
 * @param s The QString object to copy
 *
 * @complexity O(n) where n is the string length
 * @exception Strong exception safety guarantee
 *
 * @note String content is copied for independence
 * @note Preserves original string for continued use
 * @note Full Unicode support through QString
 *
 * @example
 * @code
 * QString original = "Hello, World!";
 * QTomlValue value(original);
 * original += " Modified";                // Safe to modify original
 * Q_ASSERT(value.toString() == "Hello, World!");
 * @endcode
 */
QTomlValue::QTomlValue(const QString& s)
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = String;
	d_ptr->value_ = s;
}

/**
 * @brief QString constructor with move semantics optimization.
 *
 * Creates a QTomlValue from a QString using move semantics to avoid
 * unnecessary copying. The source string becomes empty but remains
 * in a valid state after the move operation.
 *
 * @param s The QString object to move (rvalue reference)
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal move semantics
 * @note High performance through resource transfer
 * @note Source string becomes empty after move
 *
 * @example
 * @code
 * QString temp = generateLargeString();
 * QTomlValue value(std::move(temp));      // Efficient move
 * // temp is now empty but valid
 * Q_ASSERT(temp.isEmpty());
 * @endcode
 */
QTomlValue::QTomlValue(QString&& s) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = String;
	d_ptr->value_ = std::move(s);
}

/**
 * @brief QTomlArray constructor with copy semantics.
 *
 * Creates a QTomlValue containing a QTomlArray using copy semantics.
 * The array content is deep-copied, ensuring complete independence
 * between the source array and the stored array.
 *
 * @param a The QTomlArray object to copy
 *
 * @complexity O(n) where n is the number of elements in the array
 * @exception Strong exception safety guarantee
 *
 * @note Creates Array type QTomlValue
 * @note Deep copy ensures independence
 * @note All nested elements are recursively copied
 *
 * @example
 * @code
 * QTomlArray original{QTomlValue(1), QTomlValue(2)};
 * QTomlValue value(original);
 * original.append(QTomlValue(3));         // Safe to modify original
 * Q_ASSERT(value.toArray().size() == 2);
 * @endcode
 */
QTomlValue::QTomlValue(const QTomlArray& a)
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Array;
	d_ptr->value_ = a;
}

/**
 * @brief QTomlArray constructor with move semantics optimization.
 *
 * Creates a QTomlValue containing a QTomlArray using move semantics
 * to avoid deep copying. The source array becomes empty but remains
 * in a valid state after the move.
 *
 * @param a The QTomlArray object to move (rvalue reference)
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal move semantics
 * @note High performance through resource transfer
 * @note Source array becomes empty after move
 *
 * @example
 * @code
 * QTomlArray temp = generateLargeArray();
 * QTomlValue value(std::move(temp));      // Efficient move
 * // temp is now empty but valid
 * Q_ASSERT(temp.isEmpty());
 * @endcode
 */
QTomlValue::QTomlValue(QTomlArray&& a) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Array;
	d_ptr->value_ = std::move(a);
}

/**
 * @brief QTomlObject constructor with copy semantics.
 *
 * Creates a QTomlValue containing a QTomlObject using copy semantics.
 * The object table content is deep-copied, ensuring complete independence
 * between the source table and the stored table.
 *
 * @param h The QTomlObject object to copy
 *
 * @complexity O(n) where n is the number of key-value pairs
 * @exception Strong exception safety guarantee
 *
 * @note Creates Object type QTomlValue
 * @note Deep copy ensures independence
 * @note All nested values are recursively copied
 *
 * @example
 * @code
 * QTomlObject original{{"key1", QTomlValue(42)}};
 * QTomlValue value(original);
 * original.insert("key2", QTomlValue(24)); // Safe to modify original
 * Q_ASSERT(value.toObject().size() == 1);
 * @endcode
 */
QTomlValue::QTomlValue(const QTomlObject& h)
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Object;
	d_ptr->value_ = h;
}

/**
 * @brief QTomlObject constructor with move semantics optimization.
 *
 * Creates a QTomlValue containing a QTomlObject using move semantics
 * to avoid deep copying. The source object becomes empty but remains
 * in a valid state after the move.
 *
 * @param h The QTomlObject object to move (rvalue reference)
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Marked noexcept for optimal move semantics
 * @note High performance through resource transfer
 * @note Source object becomes empty after move
 *
 * @example
 * @code
 * QTomlObject temp = generateLargeObject();
 * QTomlValue value(std::move(temp));      // Efficient move
 * // temp is now empty but valid
 * Q_ASSERT(temp.isEmpty());
 * @endcode
 */
QTomlValue::QTomlValue(QTomlObject&& h) noexcept
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = Object;
	d_ptr->value_ = std::move(h);
}

/**
 * @brief QTomlDateTime constructor for date-time values.
 *
 * Creates a QTomlValue containing a QTomlDateTime object for representing
 * date, time, or date-time values according to TOML specification and
 * RFC 3339 format requirements.
 *
 * @param dt The QTomlDateTime object to store
 *
 * @complexity O(1) - Constant time (QTomlDateTime is lightweight)
 * @exception Strong exception safety guarantee
 *
 * @note Creates DateTime type QTomlValue
 * @note Supports date-only, time-only, and full date-time values
 * @note RFC 3339 compliant formatting and parsing
 *
 * @example
 * @code
 * QTomlDateTime dateTime(QDate(2023, 12, 25), QTime(10, 30, 0));
 * QTomlValue value(dateTime);
 * Q_ASSERT(value.isDateTime());
 * Q_ASSERT(value.toDateTime().date().year() == 2023);
 * @endcode
 */
QTomlValue::QTomlValue(const QTomlDateTime& dt)
	: d_ptr(std::make_unique<QTomlValuePrivate>())
{
	d_ptr->type_ = DateTime;
	d_ptr->value_ = dt;
}

/**
 * @brief Copy constructor creating independent copy.
 *
 * Creates a new QTomlValue instance that is a complete copy of the source
 * value. Uses PIMPL copy semantics to ensure proper resource management
 * and complete data independence.
 *
 * @param other The QTomlValue instance to copy from
 *
 * @complexity Depends on stored type; O(1) for primitives, O(n) for containers
 * @exception Strong exception safety guarantee
 *
 * @note Creates completely independent copy
 * @note All nested data is deep-copied
 * @note Uses PIMPL copy constructor for proper management
 *
 * @example
 * @code
 * QTomlValue original(42);
 * QTomlValue copy(original);              // Independent copy
 * Q_ASSERT(copy.toInteger() == 42);
 * // Modifications to either are independent
 * @endcode
 */
QTomlValue::QTomlValue(const QTomlValue& other)
	: d_ptr(std::make_unique<QTomlValuePrivate>(*other.d_ptr))
{
}

/**
 * @brief Move constructor for efficient resource transfer.
 * @param other Rvalue reference to source QTomlValue
 * @note Marked noexcept for optimal move semantics
 * @note Uses compiler-generated move for PIMPL smart pointer
 */
QTomlValue::QTomlValue(QTomlValue&& other) noexcept = default;

/**
 * @brief Destructor ensuring proper resource cleanup.
 * @note Marked noexcept to guarantee no exceptions during destruction
 * @note Uses RAII principles through PIMPL smart pointer
 */
QTomlValue::~QTomlValue() noexcept = default;

/**
 * @brief Copy assignment operator with self-assignment protection.
 *
 * Replaces current value content with copy of source value data.
 * Includes self-assignment checking for safety and efficiency.
 *
 * @param other The QTomlValue instance to copy from
 * @return Reference to this value for chaining assignments
 *
 * @complexity Depends on stored types; O(1) for primitives, O(n) for containers
 * @exception Strong exception safety guarantee
 *
 * @note Self-assignment safe through identity check
 * @note Uses PIMPL assignment for proper resource management
 *
 * @example
 * @code
 * QTomlValue value1, value2(42);
 * value1 = value2;                        // Copy assignment
 * Q_ASSERT(value1.toInteger() == 42);
 * @endcode
 */
QTomlValue& QTomlValue::operator=(const QTomlValue& other)
{
	if (this != &other)
	{
		*d_ptr = *other.d_ptr;
	}
	return *this;
}

/**
 * @brief Move assignment operator for efficient resource transfer.
 * @param other Rvalue reference to source QTomlValue
 * @return Reference to this value for chaining assignments
 * @note Marked noexcept for optimal performance
 * @note Uses compiler-generated move for PIMPL
 */
QTomlValue& QTomlValue::operator=(QTomlValue&& other) noexcept = default;

// ==================== Type Checking Methods ====================

/**
 * @brief Checks if value is of array type.
 * @return true if type is Array, false otherwise
 * @note Marked noexcept for performance
 * @note O(1) constant time operation
 */
bool QTomlValue::isArray() const noexcept { return d_ptr->type_ == Array; }

/**
 * @brief Checks if value is of boolean type.
 * @return true if type is Bool, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isBool() const noexcept { return d_ptr->type_ == Bool; }

/**
 * @brief Checks if value is of double type.
 * @return true if type is Double, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isDouble() const noexcept { return d_ptr->type_ == Double; }

/**
 * @brief Checks if value is of integer type.
 * @return true if type is Integer, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isInteger() const noexcept { return d_ptr->type_ == Integer; }

/**
 * @brief Checks if value is of null type.
 * @return true if type is Null, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isNull() const noexcept { return d_ptr->type_ == Null; }

/**
 * @brief Checks if value is of object type.
 * @return true if type is Object, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isObject() const noexcept { return d_ptr->type_ == Object; }

/**
 * @brief Checks if value is of string type.
 * @return true if type is String, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isString() const noexcept { return d_ptr->type_ == String; }

/**
 * @brief Checks if value is of date-time type.
 * @return true if type is DateTime, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isDateTime() const noexcept { return d_ptr->type_ == DateTime; }

/**
 * @brief Checks if value is of undefined type.
 * @return true if type is Undefined, false otherwise
 * @note Marked noexcept for performance
 */
bool QTomlValue::isUndefined() const noexcept { return d_ptr->type_ == Undefined; }

// ==================== Type Conversion Methods ====================

/**
 * @brief Converts value to QTomlArray with type safety.
 *
 * Returns the contained QTomlArray if the value is of Array type,
 * otherwise returns an empty QTomlArray. Uses optimized std::get_if
 * to avoid exceptions and unnecessary type checking overhead.
 *
 * @return QTomlArray content or empty array if wrong type
 *
 * @complexity O(1) for type checking, O(n) for array copying
 * @exception Strong exception safety guarantee
 *
 * @note Returns copy for safety
 * @note Only returns content for Array type values
 * @note Empty array returned for type mismatches
 *
 * @example
 * @code
 * QTomlValue arrayValue(QTomlArray{QTomlValue(1), QTomlValue(2)});
 * QTomlArray array = arrayValue.toArray();
 * Q_ASSERT(array.size() == 2);
 *
 * QTomlValue stringValue("not an array");
 * QTomlArray empty = stringValue.toArray();
 * Q_ASSERT(empty.isEmpty());
 * @endcode
 */
QTomlArray QTomlValue::toArray() const
{
	// Optimization: Avoid unnecessary type checking, directly use std::get_if
	if (const auto* arr = std::get_if<QTomlArray>(&d_ptr->value_))
	{
		return *arr;
	}
	return QTomlArray();
}

/**
 * @brief Converts value to boolean with default fallback.
 *
 * Returns the contained boolean value if the value is of Bool type,
 * otherwise returns the specified default value. No implicit type
 * conversion is performed from other types.
 *
 * @param defaultValue Default return value for type mismatches
 * @return Boolean value or default if wrong type
 *
 * @complexity O(1) - Constant time
 * @exception noexcept guarantee
 *
 * @note Marked noexcept for performance
 * @note No implicit conversion from numbers or strings
 * @note Only Bool type returns actual value
 *
 * @example
 * @code
 * QTomlValue boolValue(true);
 * Q_ASSERT(boolValue.toBool() == true);
 * Q_ASSERT(boolValue.toBool(false) == true);
 *
 * QTomlValue stringValue("true");
 * Q_ASSERT(stringValue.toBool(false) == false); // No implicit conversion
 * @endcode
 */
bool QTomlValue::toBool(bool defaultValue) const noexcept
{
	if (const auto* val = std::get_if<bool>(&d_ptr->value_))
	{
		return *val;
	}
	return defaultValue;
}

/**
 * @brief Converts value to double with implicit integer conversion.
 *
 * Returns the contained double value if the value is of Double type,
 * or automatically converts from Integer type (may lose precision for
 * very large integers). Returns default value for other types.
 *
 * @param defaultValue Default return value for type mismatches
 * @return Double value, converted integer, or default if wrong type
 *
 * @complexity O(1) - Constant time
 * @exception noexcept guarantee
 *
 * @note Marked noexcept for performance
 * @note Supports safe conversion from Integer to Double
 * @note Large integers may lose precision beyond 2^53
 *
 * @example
 * @code
 * QTomlValue doubleValue(3.14);
 * Q_ASSERT(doubleValue.toDouble() == 3.14);
 *
 * QTomlValue intValue(42);
 * Q_ASSERT(intValue.toDouble() == 42.0);        // Implicit conversion
 *
 * QTomlValue stringValue("not a number");
 * Q_ASSERT(stringValue.toDouble(0.0) == 0.0);   // Default returned
 * @endcode
 */
double QTomlValue::toDouble(double defaultValue) const noexcept
{
	if (const auto* val = std::get_if<double>(&d_ptr->value_))
	{
		return *val;
	}
	if (const auto* intVal = std::get_if<qint64>(&d_ptr->value_))
	{
		return static_cast<double>(*intVal);
	}
	return defaultValue;
}

/**
 * @brief Converts value to integer with truncating double conversion.
 *
 * Returns the contained integer value if the value is of Integer type,
 * or truncates from Double type (discards fractional part). Returns
 * default value for other types.
 *
 * @param defaultValue Default return value for type mismatches
 * @return Integer value, truncated double, or default if wrong type
 *
 * @complexity O(1) - Constant time
 * @exception noexcept guarantee
 *
 * @note Marked noexcept for performance
 * @note Truncation conversion from Double (no rounding)
 * @note Conversion result undefined for doubles outside integer range
 *
 * @example
 * @code
 * QTomlValue intValue(42);
 * Q_ASSERT(intValue.toInteger() == 42);
 *
 * QTomlValue doubleValue(3.14);
 * Q_ASSERT(doubleValue.toInteger() == 3);       // Truncation conversion
 *
 * QTomlValue stringValue("not a number");
 * Q_ASSERT(stringValue.toInteger(0) == 0);      // Default returned
 * @endcode
 */
qint64 QTomlValue::toInteger(qint64 defaultValue) const noexcept
{
	if (const auto* val = std::get_if<qint64>(&d_ptr->value_))
	{
		return *val;
	}
	if (const auto* doubleVal = std::get_if<double>(&d_ptr->value_))
	{
		return static_cast<qint64>(*doubleVal);
	}
	return defaultValue;
}

/**
 * @brief Converts value to QTomlObject with type safety.
 *
 * Returns the contained QTomlObject if the value is of Object type,
 * otherwise returns an empty QTomlObject.
 *
 * @return QTomlObject content or empty object if wrong type
 *
 * @complexity O(1) for type checking, O(n) for object copying
 * @exception Strong exception safety guarantee
 *
 * @note Returns copy for safety
 * @note Only returns content for Object type values
 *
 * @example
 * @code
 * QTomlValue hashValue(QTomlObject{{"key", QTomlValue(42)}});
 * QTomlObject object = hashValue.toObject();
 * Q_ASSERT(object.size() == 1);
 *
 * QTomlValue stringValue("not a object");
 * QTomlObject empty = stringValue.toObject();
 * Q_ASSERT(empty.isEmpty());
 * @endcode
 */
QTomlObject QTomlValue::toObject() const
{
	if (const auto* object = std::get_if<QTomlObject>(&d_ptr->value_))
	{
		return *object;
	}
	return QTomlObject();
}

/**
 * @brief Converts value to QTomlDateTime with type safety.
 *
 * Returns the contained QTomlDateTime if the value is of DateTime type,
 * otherwise returns an empty QTomlDateTime.
 *
 * @return QTomlDateTime content or empty date-time if wrong type
 *
 * @complexity O(1) - Constant time
 * @exception Strong exception safety guarantee
 *
 * @note Returns copy for safety
 * @note Only returns content for DateTime type values
 *
 * @example
 * @code
 * QTomlDateTime dt(QDate(2023, 12, 25));
 * QTomlValue dateValue(dt);
 * QTomlDateTime retrieved = dateValue.toDateTime();
 * Q_ASSERT(retrieved.date().year() == 2023);
 *
 * QTomlValue stringValue("not a date");
 * QTomlDateTime empty = stringValue.toDateTime();
 * Q_ASSERT(!empty.date().isValid());
 * @endcode
 */
QTomlDateTime QTomlValue::toDateTime() const
{
	if (const auto* dt = std::get_if<QTomlDateTime>(&d_ptr->value_))
	{
		return *dt;
	}
	return QTomlDateTime();
}

/**
 * @brief Converts value to QString with type safety.
 *
 * Returns the contained QString if the value is of String type,
 * otherwise returns an empty QString. No stringification of other
 * types is performed for type safety.
 *
 * @return QString content or empty string if wrong type
 *
 * @complexity O(1) for type checking, O(n) for string copying
 * @exception Strong exception safety guarantee
 *
 * @note Returns copy for safety
 * @note No automatic conversion from numbers or other types
 * @note Only String type returns actual content
 *
 * @example
 * @code
 * QTomlValue stringValue("Hello, TOML!");
 * QString str = stringValue.toString();
 * Q_ASSERT(str == "Hello, TOML!");
 *
 * QTomlValue intValue(42);
 * QString empty = intValue.toString();
 * Q_ASSERT(empty.isEmpty());              // No conversion
 * @endcode
 */
QString QTomlValue::toString() const
{
	if (const auto* str = std::get_if<QString>(&d_ptr->value_))
	{
		return *str;
	}
	return QString();
}

/**
 * @brief Converts value to QVariant for Qt integration.
 *
 * Converts the QTomlValue to its corresponding QVariant representation
 * for seamless integration with Qt's property system, signals/slots,
 * and other QVariant-based APIs. Uses std::visit for efficient type
 * dispatching and constexpr if for compile-time optimization.
 *
 * Conversion mapping:
 * - **std::monostate**: Invalid QVariant (null/undefined)
 * - **bool, qint64, double, QString**: Direct QVariant construction
 * - **Complex types**: QVariant::fromValue() wrapping
 *
 * @return Corresponding QVariant object for Qt integration
 *
 * @complexity O(1) for primitives, O(n) for complex types
 * @exception Strong exception safety guarantee
 *
 * @note Uses std::visit for optimal performance
 * @note Primitive types use direct QVariant construction
 * @note Complex types wrapped using QVariant::fromValue
 *
 * @example
 * @code
 * QTomlValue intValue(42);
 * QVariant var = intValue.toVariant();
 * Q_ASSERT(var.typeId() == QMetaType::LongLong);
 * Q_ASSERT(var.toLongLong() == 42);
 *
 * QTomlValue arrayValue(QTomlArray{QTomlValue(1)});
 * QVariant arrayVar = arrayValue.toVariant();
 * Q_ASSERT(arrayVar.canConvert<QTomlArray>());
 * @endcode
 */
QVariant QTomlValue::toVariant() const
{
	// Optimization: Use std::visit instead of switch for higher efficiency
	return std::visit([this](const auto& value) -> QVariant {
		using T = std::decay_t<decltype(value)>;
		if constexpr (std::is_same_v<T, std::monostate>) {
			return QVariant();
		}
		else if constexpr (std::is_same_v<T, bool> ||
			std::is_same_v<T, qint64> ||
			std::is_same_v<T, double> ||
			std::is_same_v<T, QString>) {
			return QVariant(value);
		}
		else {
			return QVariant::fromValue(value);
		}
		}, d_ptr->value_);
}

/**
 * @brief Gets the runtime type of the stored value.
 *
 * Returns the QTomlValue::Type enumeration value representing
 * the currently stored data type for runtime type checking
 * and conditional logic.
 *
 * @return Type enumeration value for the stored type
 *
 * @complexity O(1) - Constant time
 * @exception noexcept guarantee
 *
 * @note Marked noexcept for performance
 * @note Cached type information for fast access
 * @note Suitable for switch statements and conditional logic
 *
 * @example
 * @code
 * QTomlValue value(42);
 * switch (value.type()) {
 *     case QTomlValue::Integer:
 *         qDebug() << "Integer:" << value.toInteger();
 *         break;
 *     case QTomlValue::String:
 *         qDebug() << "String:" << value.toString();
 *         break;
 *     default:
 *         qDebug() << "Other type";
 * }
 * @endcode
 */
QTomlValue::Type QTomlValue::type() const noexcept { return d_ptr->type_; }

/**
 * @brief Efficiently swaps content with another QTomlValue.
 *
 * Swaps the complete content of two QTomlValue objects without copying.
 * Uses smart pointer swap for optimal performance and exception safety.
 * After swapping, both objects have exchanged their types and values.
 *
 * @param other The other QTomlValue to swap content with
 *
 * @complexity O(1) - Constant time
 * @exception noexcept guarantee
 *
 * @note Marked noexcept for optimal performance
 * @note Uses PIMPL smart pointer swap for efficiency
 * @note Both objects' content are completely exchanged
 *
 * @example
 * @code
 * QTomlValue value1(42);
 * QTomlValue value2("hello");
 *
 * value1.swap(value2);                    // Efficient swap
 * Q_ASSERT(value1.toString() == "hello");
 * Q_ASSERT(value2.toInteger() == 42);
 * @endcode
 */
void QTomlValue::swap(QTomlValue& other) noexcept { d_ptr.swap(other.d_ptr); }

// ==================== Qt JSON API Compatibility Method Implementations ====================

/**
 * @brief Converts the value to QTomlArray with default fallback.
 *
 * Implementation of Qt JSON API compatible toArray method with default value support.
 * If the current value is not an array, returns the provided default instead of empty array.
 *
 * @example
 * @code
 * QTomlValue value(QTomlValue::String);  // Non-array value
 * QTomlArray defaultArray{"default", "values"};
 * QTomlArray result = value.toArray(defaultArray);
 * Q_ASSERT(result.size() == 2);  // Got default array
 * @endcode
 */
QTomlArray QTomlValue::toArray(const QTomlArray& defaultValue) const
{
	if (isArray()) {
		return toArray();  // Use existing implementation
	}
	return defaultValue;  // Return provided default
}

/**
 * @brief Converts the value to QTomlObject with default fallback.
 *
 * Implementation of Qt JSON API compatible toObject method with default value support.
 * If the current value is not an object, returns the provided default instead of empty object.
 *
 * @example
 * @code
 * QTomlValue value(42);  // Non-object value
 * QTomlObject defaultObj{{"default", QTomlValue("value")}};
 * QTomlObject result = value.toObject(defaultObj);
 * Q_ASSERT(result.contains("default"));  // Got default object
 * @endcode
 */
QTomlObject QTomlValue::toObject(const QTomlObject& defaultValue) const
{
	if (isObject()) {
		return toObject();  // Use existing implementation
	}
	return defaultValue;  // Return provided default
}

/**
 * @brief Converts the value to QString with default fallback.
 *
 * Implementation of Qt JSON API compatible toString method with default value support.
 * If the current value is not a string, returns the provided default instead of empty string.
 *
 * @example
 * @code
 * QTomlValue value(42);  // Non-string value
 * QString result = value.toString("default");
 * Q_ASSERT(result == "default");  // Got default string
 * @endcode
 */
QString QTomlValue::toString(const QString& defaultValue) const
{
	if (isString()) {
		return toString();  // Use existing implementation
	}
	return defaultValue;  // Return provided default
}

/**
 * @brief Converts the value to 32-bit integer with default fallback.
 *
 * Implementation of Qt JSON API compatible toInt method. Provides same conversion
 * logic as toInteger but with 32-bit return type and custom default support.
 *
 * @example
 * @code
 * QTomlValue intValue(123);
 * QTomlValue stringValue("not a number");
 * 
 * int result1 = intValue.toInt();        // 123
 * int result2 = stringValue.toInt(999);  // 999 (default)
 * @endcode
 */
int QTomlValue::toInt(int defaultValue) const noexcept
{
	qint64 longResult = toInteger(static_cast<qint64>(defaultValue));
	
	// Clamp to 32-bit range to prevent overflow
	if (longResult > std::numeric_limits<int>::max()) {
		return std::numeric_limits<int>::max();
	} else if (longResult < std::numeric_limits<int>::min()) {
		return std::numeric_limits<int>::min();
	}
	
	return static_cast<int>(longResult);
}

/**
 * @brief Checks if the value represents valid data.
 *
 * Implementation of Qt class standard isValid method. Returns false only for
 * undefined values, all other states (including null) are considered valid.
 *
 * @example
 * @code
 * QTomlValue validValue(42);
 * QTomlValue nullValue;
 * QTomlValue undefinedValue(QTomlValue::Undefined);
 * 
 * Q_ASSERT(validValue.isValid());     // true - has data
 * Q_ASSERT(nullValue.isValid());      // true - null is valid state
 * Q_ASSERT(!undefinedValue.isValid()); // false - undefined is invalid
 * @endcode
 */
bool QTomlValue::isValid() const noexcept
{
	return !isUndefined();  // Only undefined values are invalid
}

/**
 * @brief Creates QTomlValue from QVariant object.
 *
 * Implementation of Qt JSON API compatible fromVariant static method.
 * Performs comprehensive type mapping from QVariant to QTomlValue.
 *
 * @example
 * @code
 * QVariant stringVar("hello");
 * QVariant intVar(42);
 * QVariant boolVar(true);
 * 
 * QTomlValue val1 = QTomlValue::fromVariant(stringVar);
 * QTomlValue val2 = QTomlValue::fromVariant(intVar);
 * QTomlValue val3 = QTomlValue::fromVariant(boolVar);
 * 
 * Q_ASSERT(val1.toString() == "hello");
 * Q_ASSERT(val2.toInteger() == 42);
 * Q_ASSERT(val3.toBool() == true);
 * @endcode
 */
QTomlValue QTomlValue::fromVariant(const QVariant& variant)
{
	// Handle null/invalid variants
	if (!variant.isValid() || variant.isNull()) {
		return QTomlValue();  // Return null QTomlValue
	}

	// Direct QTomlValue extraction
	if (variant.canConvert<QTomlValue>()) {
		return variant.value<QTomlValue>();
	}

	// Handle basic types using Qt 6 typeId() API with switch
	switch (variant.typeId()) {
		case QMetaType::Bool:
			return QTomlValue(variant.toBool());
			
		// Signed integer types
		case QMetaType::Int:
			return QTomlValue(static_cast<qint64>(variant.toInt()));
		case QMetaType::LongLong:
			return QTomlValue(variant.toLongLong());
		case QMetaType::Short:
			return QTomlValue(static_cast<qint64>(variant.value<short>()));
		case QMetaType::Char:
			return QTomlValue(static_cast<qint64>(variant.toChar().toLatin1()));
		case QMetaType::SChar:
			return QTomlValue(static_cast<qint64>(variant.value<signed char>()));
			
		// Unsigned integer types (with overflow checking for large values)
		case QMetaType::UInt:
			return QTomlValue(static_cast<qint64>(variant.toUInt()));
		case QMetaType::ULongLong: {
			qulonglong val = variant.toULongLong();
			// Check for overflow when converting to signed
			if (val <= static_cast<qulonglong>(std::numeric_limits<qint64>::max())) {
				return QTomlValue(static_cast<qint64>(val));
			} else {
				// Convert to double for very large unsigned values
				return QTomlValue(static_cast<double>(val));
			}
		}
		case QMetaType::UShort:
			return QTomlValue(static_cast<qint64>(variant.value<unsigned short>()));
		case QMetaType::UChar:
			return QTomlValue(static_cast<qint64>(variant.value<unsigned char>()));
			
		// Floating point types
		case QMetaType::Double:
			return QTomlValue(variant.toDouble());
		case QMetaType::Float:
			return QTomlValue(static_cast<double>(variant.toFloat()));
			
		// String types
		case QMetaType::QString:
			return QTomlValue(variant.toString());
		case QMetaType::QByteArray:
			return QTomlValue(QString::fromUtf8(variant.toByteArray()));
		case QMetaType::QChar:
			return QTomlValue(QString(variant.toChar()));
			
		default:
			break;
	}

	// Handle QToml types
	if (variant.canConvert<QTomlArray>()) {
		return QTomlValue(variant.value<QTomlArray>());
	}
	
	if (variant.canConvert<QTomlObject>()) {
		return QTomlValue(variant.value<QTomlObject>());
	}
	
	if (variant.canConvert<QTomlDateTime>()) {
		return QTomlValue(variant.value<QTomlDateTime>());
	}

	// Unsupported type - return null
	return QTomlValue();
}

/**
 * @brief Const subscript operator for object key access.
 *
 * Implementation of Qt JSON API compatible operator[] for key access.
 * Safely handles non-object values by returning null instead of crashing.
 *
 * @example
 * @code
 * QTomlObject obj{{"key", QTomlValue("value")}};
 * QTomlValue objectValue(obj);
 * QTomlValue nonObjectValue(42);
 * 
 * QTomlValue result1 = objectValue["key"];        // "value"
 * QTomlValue result2 = objectValue["missing"];    // null
 * QTomlValue result3 = nonObjectValue["key"];     // null (safe)
 * @endcode
 */
const QTomlValue QTomlValue::operator[](const QString& key) const
{
	if (isObject()) {
		QTomlObject obj = toObject();
		if (obj.contains(key)) {
			return obj.value(key);
		}
	}
	return QTomlValue();  // Return null for missing keys or non-objects
}

/**
 * @brief Const subscript operator for array index access.
 *
 * Implementation of Qt JSON API compatible operator[] for index access.
 * Safely handles non-array values and out-of-bounds access by returning null.
 *
 * @example
 * @code
 * QTomlArray arr{QTomlValue("first"), QTomlValue("second")};
 * QTomlValue arrayValue(arr);
 * QTomlValue nonArrayValue("not an array");
 * 
 * QTomlValue result1 = arrayValue[0];    // "first"
 * QTomlValue result2 = arrayValue[10];   // null (out of bounds)
 * QTomlValue result3 = nonArrayValue[0]; // null (not an array)
 * @endcode
 */
const QTomlValue QTomlValue::operator[](qsizetype i) const
{
	if (isArray()) {
		QTomlArray arr = toArray();
		if (i >= 0 && i < arr.size()) {
			return arr.at(i);
		}
	}
	return QTomlValue();  // Return null for out-of-bounds or non-arrays
}