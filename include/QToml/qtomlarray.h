/*
 * MIT License
 *
 * Copyright (c) 2025 QToml Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Project Information:
 * - Generated by: Claude 4.0 Sonnet (Anthropic AI) on 2025-08-30
 * - Verified and reviewed by: Bestkakkoii
 * - Original project structure and implementation concepts
 * - Built upon toml++ library (https://github.com/marzer/tomlplusplus)
 * - Qt framework integration and wrapper implementation
 */

 /**
  * @file qtomlarray.h
  * @brief Declaration of QTomlArray class for TOML array value representation and manipulation.
  *
  * This header defines the QTomlArray class, which provides a dynamic array container
  * for TOML values. The class implements the TOML array semantics as defined in the
  * TOML v1.0.0 specification, supporting heterogeneous element types and nested
  * structures including arrays and tables.
  *
  * TOML array features supported:
  * - Heterogeneous arrays containing mixed value types
  * - Nested arrays and tables for complex data structures
  * - Dynamic resizing with efficient memory management
  * - High-performance random access to elements
  * - Full compliance with TOML v1.0.0 array specifications
  *
  * The implementation provides:
  * - Qt-style API similar to QJsonArray for familiar usage patterns
  * - STL-compatible iterators for range-based loops and algorithms
  * - Efficient memory management through PIMPL pattern
  * - Value semantics with copy-on-write optimization potential
  * - Exception-safe operations with strong guarantees
  *
  * Performance characteristics:
  * - O(1) random access to elements by index
  * - O(1) amortized append operations
  * - O(n) insertion and removal in the middle
  * - Optimized for both small and large arrays
  *
  * @note This class follows Qt conventions for container interfaces
  * @note All index operations use 0-based indexing
  * @note Debug builds include bounds checking with assertions
  * @see QTomlValue for element type information
  * @see QTomlObject for table/object containers
  * @see QTomlDocument for complete document handling
  */

#pragma once
#pragma execution_character_set("utf-8")

#include "qtomlvalue.h"

#include <QObject>
#include <QtGlobal>
#include <QVariantList>
#include <QVector>
#include <memory>
#include <initializer_list>

  /**
   * @class QTomlArray
   * @brief Dynamic array container for TOML values supporting heterogeneous element types.
   *
   * QTomlArray provides a dynamic array container specifically designed for TOML
   * values, implementing the array semantics defined in the TOML v1.0.0 specification.
   * Unlike JSON arrays which are typically homogeneous, TOML arrays can contain
   * mixed value types, making this class suitable for complex data structures.
   *
   * The class serves multiple purposes:
   * - **Data Storage**: Efficient storage for sequences of TOML values
   * - **Type Safety**: Proper handling of TOML's heterogeneous array semantics
   * - **Performance**: Optimized operations for common array manipulations
   * - **Integration**: Seamless interoperability with Qt's container ecosystem
   * - **Standards Compliance**: Full adherence to TOML array specifications
   *
   * Key design principles:
   * - **Value Semantics**: Safe copying and assignment with independent instances
   * - **Performance**: O(1) random access and amortized O(1) append operations
   * - **Flexibility**: Support for mixed element types and nested structures
   * - **Safety**: Bounds checking in debug builds and exception-safe operations
   * - **Compatibility**: Qt-style interface familiar to Qt developers
   *
   * Array element types supported:
   * - Primitive values (strings, numbers, booleans, dates/times)
   * - Nested arrays for multi-dimensional data structures
   * - Hash tables for complex object relationships
   * - Mixed types within the same array (heterogeneous arrays)
   *
   * Memory management:
   * - PIMPL pattern for binary compatibility and efficient copying
   * - Automatic memory management through RAII principles
   * - Optimized for both small arrays and large datasets
   * - Potential copy-on-write optimization for efficient copying
   *
   * Thread safety:
   * - Read operations are thread-safe (const methods)
   * - Modification requires external synchronization
   * - Copy construction is thread-safe
   * - Independent copies can be used concurrently
   *
   * @note All index operations use 0-based indexing following C++ conventions
   * @note Debug builds include comprehensive bounds checking
   * @note The class is registered with Qt's Meta-Object System for QVariant support
   *
   * @example Basic array operations:
   * @code
   * // Create and populate array
   * QTomlArray array;
   * array.append(QTomlValue("hello"));
   * array.append(QTomlValue(42));
   * array.append(QTomlValue(true));
   *
   * // Access elements
   * Q_ASSERT(array.size() == 3);
   * Q_ASSERT(array.at(0).toString() == "hello");
   * Q_ASSERT(array.at(1).toInteger() == 42);
   * Q_ASSERT(array.at(2).toBool() == true);
   * @endcode
   *
   * @example Nested structures:
   * @code
   * // Create nested array structure
   * QTomlArray innerArray;
   * innerArray.append(QTomlValue(1));
   * innerArray.append(QTomlValue(2));
   *
   * QTomlArray outerArray;
   * outerArray.append(QTomlValue("data"));
   * outerArray.append(QTomlValue(innerArray));
   *
   * // Access nested elements
   * QTomlArray retrieved = outerArray.at(1).toArray();
   * Q_ASSERT(retrieved.at(0).toInteger() == 1);
   * @endcode
   *
   * @example Iterator usage:
   * @code
   * QTomlArray array = createSampleArray();
   *
   * // Range-based for loop
   * for (const auto& value : array) {
   *     qDebug() << "Value:" << value.toString();
   * }
   *
   * // STL-style iteration
   * auto it = std::find_if(array.begin(), array.end(),
   *     [](const QTomlValue& v) { return v.isInteger(); });
   * if (it != array.end()) {
   *     qDebug() << "Found integer:" << it->toInteger();
   * }
   * @endcode
   *
   * @see QTomlValue for element value representation
   * @see QTomlObject for table/object containers
   * @see QTomlDocument for complete document handling
   * @see QJsonArray for similar JSON array functionality
   */
class Q_CORE_EXPORT QTomlArray
{
	Q_GADGET
public:
	// ==================== Type Definitions ====================

	/**
	 * @brief Mutable iterator type for element traversal and modification.
	 *
	 * Provides STL-compatible mutable iterator interface for traversing
	 * and modifying array elements. Supports all standard iterator operations
	 * including increment, decrement, dereferencing, and random access.
	 *
	 * @note Based on QVector<QTomlValue>::iterator for performance
	 * @note Supports random access iterator operations
	 * @note Invalidated by array modifications that change capacity
	 */
	using iterator = QVector<QTomlValue>::iterator;

	/**
	 * @brief Immutable iterator type for read-only element traversal.
	 *
	 * Provides STL-compatible const iterator interface for read-only
	 * traversal of array elements. Ensures that elements cannot be
	 * modified through the iterator interface.
	 *
	 * @note Based on QVector<QTomlValue>::const_iterator for performance
	 * @note Supports random access iterator operations
	 * @note Safe to use with const QTomlArray instances
	 */
	using const_iterator = QVector<QTomlValue>::const_iterator;

	// ==================== Construction and Destruction ====================

	/**
	 * @brief Default constructor creating an empty array.
	 *
	 * Creates a QTomlArray with no elements, ready for population through
	 * append, insert, or other modification operations. The array starts
	 * with zero capacity and will allocate memory as needed.
	 *
	 * @complexity O(1) - Constant time construction
	 * @exception noexcept guarantee
	 *
	 * @note Creates empty array with zero capacity
	 * @note Memory is allocated on first element addition
	 * @note Marked noexcept for optimal performance
	 *
	 * @example
	 * @code
	 * QTomlArray array;              // Empty array
	 * Q_ASSERT(array.isEmpty());     // Verify empty state
	 * Q_ASSERT(array.size() == 0);   // No elements
	 * @endcode
	 */
	QTomlArray() noexcept;

	/**
	 * @brief Initializer list constructor for convenient array creation.
	 *
	 * Creates a QTomlArray from an initializer list of QTomlValue objects,
	 * enabling convenient syntax for array creation with initial values.
	 * This constructor supports both uniform initialization and direct
	 * list initialization patterns.
	 *
	 * @param args Initializer list of QTomlValue objects
	 *
	 * @complexity O(n) where n is the number of elements in the list
	 * @exception Strong exception safety guarantee
	 *
	 * @note Enables convenient array initialization syntax
	 * @note All elements are copied from the initializer list
	 * @note Memory is allocated to exactly fit the provided elements
	 *
	 * @example
	 * @code
	 * // Uniform initialization
	 * QTomlArray array1{
	 *     QTomlValue("string"),
	 *     QTomlValue(42),
	 *     QTomlValue(true)
	 * };
	 *
	 * // Direct initialization
	 * QTomlArray array2({
	 *     QTomlValue(1.5),
	 *     QTomlValue("test")
	 * });
	 *
	 * Q_ASSERT(array1.size() == 3);
	 * Q_ASSERT(array2.size() == 2);
	 * @endcode
	 */
	QTomlArray(std::initializer_list<QTomlValue> args);

	/**
	 * @brief Copy constructor creating independent array copy.
	 *
	 * Creates a new QTomlArray that is an exact copy of another array,
	 * including all elements and internal state. The copy is completely
	 * independent - modifications to either array will not affect the other.
	 *
	 * @param other The QTomlArray object to copy from
	 *
	 * @complexity O(n) where n is the number of elements
	 * @exception Strong exception safety guarantee
	 *
	 * @note Creates completely independent copy
	 * @note All elements are deep-copied
	 * @note Uses PIMPL pattern for efficient copying
	 */
	QTomlArray(const QTomlArray& other);

	/**
	 * @brief Move constructor for efficient array transfer.
	 *
	 * Creates a QTomlArray by taking ownership of another array's resources,
	 * leaving the source in a valid but unspecified state. Enables efficient
	 * array transfer and return value optimization.
	 *
	 * @param other Rvalue reference to QTomlArray to move from
	 *
	 * @complexity O(1) - Constant time resource transfer
	 * @exception noexcept guarantee
	 *
	 * @note Source array remains valid but should not be used
	 * @note Enables return value optimization
	 * @note Optimal for temporary objects and function returns
	 */
	QTomlArray(QTomlArray&& other) noexcept;

	/**
	 * @brief Virtual destructor ensuring proper cleanup.
	 *
	 * Automatically releases all resources through RAII principles.
	 * Uses std::unique_ptr for automatic memory management of the
	 * private implementation.
	 *
	 * @complexity O(n) where n is the number of elements
	 * @exception noexcept guarantee
	 *
	 * @note Virtual for potential future inheritance
	 * @note Automatic cleanup through RAII
	 * @note All elements are properly destroyed
	 */
	virtual ~QTomlArray() noexcept;

	/**
	 * @brief Copy assignment operator with self-assignment protection.
	 *
	 * Replaces this array's contents with a copy of another array's
	 * elements. Includes protection against self-assignment for safety
	 * and efficiency.
	 *
	 * @param other The QTomlArray object to copy from
	 * @return Reference to this object for assignment chaining
	 *
	 * @complexity O(n) where n is the number of elements
	 * @exception Strong exception safety guarantee
	 *
	 * @note Self-assignment is detected and handled safely
	 * @note Supports assignment chaining
	 * @note Previous contents are replaced
	 */
	QTomlArray& operator=(const QTomlArray& other);

	/**
	 * @brief Move assignment operator for efficient resource transfer.
	 *
	 * Replaces this array's contents by taking ownership of another
	 * array's resources. Previous contents are automatically cleaned up.
	 *
	 * @param other Rvalue reference to QTomlArray to move from
	 * @return Reference to this object for assignment chaining
	 *
	 * @complexity O(1) - Constant time resource transfer
	 * @exception noexcept guarantee
	 *
	 * @note Previous contents are automatically cleaned up
	 * @note Source array should not be used after move
	 * @note Supports assignment chaining
	 */
	QTomlArray& operator=(QTomlArray&& other) noexcept;

	// ==================== Capacity Management ====================

	/**
	 * @brief Reserves memory capacity for anticipated elements.
	 *
	 * Pre-allocates memory to accommodate at least the specified number
	 * of elements without requiring reallocation. This optimization is
	 * useful when the final array size is known in advance.
	 *
	 * @param size Number of elements to reserve capacity for
	 *
	 * @complexity O(n) where n is the new capacity
	 * @exception Strong exception safety guarantee
	 *
	 * @note Does not change array size, only capacity
	 * @note Improves performance for known-size arrays
	 * @note No effect if current capacity is already sufficient
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 * array.reserve(1000);           // Pre-allocate for 1000 elements
	 *
	 * // Efficient appending without reallocations
	 * for (int i = 0; i < 1000; ++i) {
	 *     array.append(QTomlValue(i));
	 * }
	 * @endcode
	 */
	void reserve(qsizetype size);

	/**
	 * @brief Returns the current allocated capacity of the array.
	 *
	 * Returns the number of elements that can be stored without
	 * requiring memory reallocation. The capacity is always greater
	 * than or equal to the size.
	 *
	 * @return Current allocated capacity in number of elements
	 *
	 * @complexity O(1) - Constant time access
	 * @exception noexcept guarantee
	 *
	 * @note Capacity is always >= size()
	 * @note Useful for performance analysis and optimization
	 * @note May be larger than size() due to allocation strategy
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 * Q_ASSERT(array.capacity() == 0);  // Empty array
	 *
	 * array.reserve(100);
	 * Q_ASSERT(array.capacity() >= 100); // At least 100
	 * Q_ASSERT(array.size() == 0);       // Still empty
	 * @endcode
	 */
	qsizetype capacity() const noexcept;

	// ==================== Element Modification ====================

	/**
	 * @brief Appends a value to the end of the array (copy version).
	 *
	 * Adds a new element to the end of the array by copying the provided
	 * value. The array size increases by one, and memory may be reallocated
	 * if necessary to accommodate the new element.
	 *
	 * @param value The QTomlValue to append to the array
	 *
	 * @complexity O(1) amortized - may be O(n) during reallocation
	 * @exception Strong exception safety guarantee
	 *
	 * @note Value is copied into the array
	 * @note Array size increases by one
	 * @note May trigger memory reallocation
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 * QTomlValue value("hello");
	 *
	 * array.append(value);           // Copy value
	 * Q_ASSERT(array.size() == 1);
	 * Q_ASSERT(array.at(0).toString() == "hello");
	 * @endcode
	 */
	void append(const QTomlValue& value);

	/**
	 * @brief Appends a value to the end of the array (move version).
	 *
	 * Adds a new element to the end of the array by moving the provided
	 * value. This is more efficient than copying for temporary values
	 * and rvalue references.
	 *
	 * @param value Rvalue reference to QTomlValue to move into the array
	 *
	 * @complexity O(1) amortized - may be O(n) during reallocation
	 * @exception Strong exception safety guarantee
	 *
	 * @note Value is moved into the array (no copying)
	 * @note More efficient for temporary values
	 * @note Source value should not be used after move
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 *
	 * array.append(QTomlValue("temp"));     // Move temporary
	 * array.append(std::move(someValue));   // Explicit move
	 * Q_ASSERT(array.size() == 2);
	 * @endcode
	 */
	void append(QTomlValue&& value);

	/**
	 * @brief Prepends a value to the beginning of the array (copy version).
	 *
	 * Inserts a new element at the beginning of the array by copying the
	 * provided value. All existing elements are shifted one position to
	 * the right, and the array size increases by one.
	 *
	 * @param value The QTomlValue to prepend to the array
	 *
	 * @complexity O(n) where n is the number of existing elements
	 * @exception Strong exception safety guarantee
	 *
	 * @note All existing elements are shifted right
	 * @note Less efficient than append() due to element shifting
	 * @note Value is copied into the array
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 * array.append(QTomlValue("second"));
	 * array.prepend(QTomlValue("first"));
	 *
	 * Q_ASSERT(array.at(0).toString() == "first");
	 * Q_ASSERT(array.at(1).toString() == "second");
	 * @endcode
	 */
	void prepend(const QTomlValue& value);

	/**
	 * @brief Prepends a value to the beginning of the array (move version).
	 *
	 * Inserts a new element at the beginning of the array by moving the
	 * provided value. More efficient than the copy version for temporary
	 * values and rvalue references.
	 *
	 * @param value Rvalue reference to QTomlValue to move to array beginning
	 *
	 * @complexity O(n) where n is the number of existing elements
	 * @exception Strong exception safety guarantee
	 *
	 * @note All existing elements are shifted right
	 * @note More efficient than copy version for temporaries
	 * @note Source value should not be used after move
	 */
	void prepend(QTomlValue&& value);

	/**
	 * @brief Inserts a value at the specified index (copy version).
	 *
	 * Inserts a new element at the given index by copying the provided value.
	 * All elements at and after the insertion point are shifted one position
	 * to the right, and the array size increases by one.
	 *
	 * @param i Index where to insert the value (0-based)
	 * @param value The QTomlValue to insert
	 *
	 * @complexity O(n) where n is the number of elements after insertion point
	 * @exception Strong exception safety guarantee
	 *
	 * @note Index must be in range [0, size()]
	 * @note Elements after insertion point are shifted right
	 * @note Value is copied into the array
	 * @note Debug builds include bounds checking
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 * array.append(QTomlValue("first"));
	 * array.append(QTomlValue("third"));
	 * array.insert(1, QTomlValue("second"));
	 *
	 * Q_ASSERT(array.at(0).toString() == "first");
	 * Q_ASSERT(array.at(1).toString() == "second");
	 * Q_ASSERT(array.at(2).toString() == "third");
	 * @endcode
	 */
	void insert(qsizetype i, const QTomlValue& value);

	/**
	 * @brief Inserts a value at the specified index (move version).
	 *
	 * Inserts a new element at the given index by moving the provided value.
	 * More efficient than the copy version for temporary values and rvalue
	 * references.
	 *
	 * @param i Index where to insert the value (0-based)
	 * @param value Rvalue reference to QTomlValue to move into the array
	 *
	 * @complexity O(n) where n is the number of elements after insertion point
	 * @exception Strong exception safety guarantee
	 *
	 * @note Index must be in range [0, size()]
	 * @note More efficient than copy version for temporaries
	 * @note Source value should not be used after move
	 */
	void insert(qsizetype i, QTomlValue&& value);

	/**
	 * @brief Removes the element at the specified index.
	 *
	 * Removes the element at the given index from the array. All elements
	 * after the removal point are shifted one position to the left, and
	 * the array size decreases by one.
	 *
	 * @param i Index of the element to remove (0-based)
	 *
	 * @complexity O(n) where n is the number of elements after removal point
	 * @exception Strong exception safety guarantee
	 *
	 * @note Index must be in range [0, size()-1]
	 * @note Elements after removal point are shifted left
	 * @note Debug builds include bounds checking
	 * @note Removed element is destroyed
	 *
	 * @example
	 * @code
	 * QTomlArray array{"first", "second", "third"};
	 * array.removeAt(1);  // Remove "second"
	 *
	 * Q_ASSERT(array.size() == 2);
	 * Q_ASSERT(array.at(0).toString() == "first");
	 * Q_ASSERT(array.at(1).toString() == "third");
	 * @endcode
	 */
	void removeAt(qsizetype i);

	/**
	 * @brief Replaces the element at the specified index (copy version).
	 *
	 * Replaces the element at the given index with a copy of the provided
	 * value. The array size remains unchanged, and no element shifting occurs.
	 *
	 * @param i Index of the element to replace (0-based)
	 * @param value The QTomlValue to replace the existing element with
	 *
	 * @complexity O(1) - Constant time operation
	 * @exception Strong exception safety guarantee
	 *
	 * @note Index must be in range [0, size()-1]
	 * @note Array size remains unchanged
	 * @note Previous element is destroyed
	 * @note Value is copied into the array
	 *
	 * @example
	 * @code
	 * QTomlArray array{"old", "value"};
	 * array.replace(0, QTomlValue("new"));
	 *
	 * Q_ASSERT(array.at(0).toString() == "new");
	 * Q_ASSERT(array.at(1).toString() == "value");
	 * @endcode
	 */
	void replace(qsizetype i, const QTomlValue& value);

	/**
	 * @brief Replaces the element at the specified index (move version).
	 *
	 * Replaces the element at the given index by moving the provided value.
	 * More efficient than the copy version for temporary values and rvalue
	 * references.
	 *
	 * @param i Index of the element to replace (0-based)
	 * @param value Rvalue reference to QTomlValue to move into the array
	 *
	 * @complexity O(1) - Constant time operation
	 * @exception Strong exception safety guarantee
	 *
	 * @note Index must be in range [0, size()-1]
	 * @note More efficient than copy version for temporaries
	 * @note Source value should not be used after move
	 */
	void replace(qsizetype i, QTomlValue&& value);

	/**
	 * @brief Removes and returns the element at the specified index.
	 *
	 * Removes the element at the given index from the array and returns
	 * it by value. All elements after the removal point are shifted one
	 * position to the left, and the array size decreases by one.
	 *
	 * @param i Index of the element to take (0-based)
	 * @return The QTomlValue that was removed from the array
	 *
	 * @complexity O(n) where n is the number of elements after removal point
	 * @exception Strong exception safety guarantee
	 *
	 * @note Index must be in range [0, size()-1]
	 * @note Elements after removal point are shifted left
	 * @note Returned value is independent of the array
	 * @note Useful for transferring elements between arrays
	 *
	 * @example
	 * @code
	 * QTomlArray array{"first", "second", "third"};
	 * QTomlValue taken = array.takeAt(1);
	 *
	 * Q_ASSERT(taken.toString() == "second");
	 * Q_ASSERT(array.size() == 2);
	 * Q_ASSERT(array.at(1).toString() == "third");
	 * @endcode
	 */
	QTomlValue takeAt(qsizetype i);

	// ==================== Element Access ====================

	/**
	 * @brief Returns a copy of the element at the specified index.
	 *
	 * Retrieves the element at the given index and returns it by value.
	 * The returned value is independent of the array and can be modified
	 * without affecting the original array element.
	 *
	 * @param i Index of the element to retrieve (0-based)
	 * @return Copy of the QTomlValue at the specified index
	 *
	 * @complexity O(1) - Constant time access with copying overhead
	 * @exception Strong exception safety guarantee
	 *
	 * @note Index must be in range [0, size()-1]
	 * @note Returns a copy, not a reference
	 * @note Debug builds include bounds checking
	 * @note Safe for concurrent read access
	 *
	 * @example
	 * @code
	 * QTomlArray array{"hello", 42, true};
	 *
	 * QTomlValue first = array.at(0);
	 * Q_ASSERT(first.toString() == "hello");
	 *
	 * QTomlValue second = array.at(1);
	 * Q_ASSERT(second.toInteger() == 42);
	 * @endcode
	 */
	QTomlValue at(qsizetype i) const;
	QTomlValue value(qsizetype i, const QTomlValue& defaultValue = QTomlValue()) const;
	QTomlValue& operator[](qsizetype i);
	QTomlValue operator[](qsizetype i) const;

	/**
	 * @brief Returns a const reference to the element at the specified index (unsafe).
	 *
	 * Retrieves a const reference to the element at the given index without
	 * bounds checking. This is an optimized version for performance-critical
	 * code where bounds have been verified externally.
	 *
	 * @param i Index of the element to retrieve (0-based)
	 * @return Const reference to the QTomlValue at the specified index
	 *
	 * @complexity O(1) - Constant time direct access
	 * @exception noexcept guarantee (no bounds checking)
	 *
	 * @warning No bounds checking is performed - undefined behavior for invalid indices
	 * @note Returns a reference, not a copy
	 * @note Use only when bounds are guaranteed to be valid
	 * @note Marked noexcept for performance optimization
	 *
	 * @example
	 * @code
	 * QTomlArray array{"test", "data"};
	 *
	 * // Safe usage with bounds check
	 * if (index < array.size()) {
	 *     const QTomlValue& value = array.at_unsafe(index);
	 *     // Use value...
	 * }
	 * @endcode
	 */
	const QTomlValue& at_unsafe(qsizetype i) const noexcept;

	/**
	 * @brief Returns a copy of the first element in the array.
	 *
	 * Retrieves the first element (index 0) and returns it by value.
	 * This is a convenience method equivalent to at(0) but with more
	 * expressive semantics.
	 *
	 * @return Copy of the first QTomlValue in the array
	 *
	 * @complexity O(1) - Constant time access with copying overhead
	 * @exception Strong exception safety guarantee
	 *
	 * @note Array must not be empty
	 * @note Returns a copy, not a reference
	 * @note Debug builds include empty array checking
	 *
	 * @example
	 * @code
	 * QTomlArray array{"first", "second", "third"};
	 * QTomlValue firstElement = array.first();
	 * Q_ASSERT(firstElement.toString() == "first");
	 * @endcode
	 */
	QTomlValue first() const;

	/**
	 * @brief Returns a copy of the last element in the array.
	 *
	 * Retrieves the last element (index size()-1) and returns it by value.
	 * This is a convenience method equivalent to at(size()-1) but with more
	 * expressive semantics.
	 *
	 * @return Copy of the last QTomlValue in the array
	 *
	 * @complexity O(1) - Constant time access with copying overhead
	 * @exception Strong exception safety guarantee
	 *
	 * @note Array must not be empty
	 * @note Returns a copy, not a reference
	 * @note Debug builds include empty array checking
	 *
	 * @example
	 * @code
	 * QTomlArray array{"first", "second", "last"};
	 * QTomlValue lastElement = array.last();
	 * Q_ASSERT(lastElement.toString() == "last");
	 * @endcode
	 */
	QTomlValue last() const;

	// ==================== Container Information ====================

	/**
	 * @brief Returns the number of elements in the array.
	 *
	 * Returns the current number of elements stored in the array.
	 * This is the logical size, which may be different from the
	 * allocated capacity.
	 *
	 * @return Number of elements in the array
	 *
	 * @complexity O(1) - Constant time access
	 * @exception noexcept guarantee
	 *
	 * @note Always returns a non-negative value
	 * @note May be different from capacity()
	 * @note Zero for empty arrays
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 * Q_ASSERT(array.size() == 0);
	 *
	 * array.append(QTomlValue("test"));
	 * Q_ASSERT(array.size() == 1);
	 * @endcode
	 */
	qsizetype size() const noexcept;

	/**
	 * @brief Returns the number of elements in the array (alias for size()).
	 *
	 * Convenience method that returns the same value as size().
	 * Provided for compatibility with Qt container conventions
	 * and developer preference.
	 *
	 * @return Number of elements in the array
	 *
	 * @complexity O(1) - Constant time access
	 * @exception noexcept guarantee
	 *
	 * @note Identical to size() method
	 * @note Provided for Qt container consistency
	 *
	 * @example
	 * @code
	 * QTomlArray array{"a", "b", "c"};
	 * Q_ASSERT(array.count() == 3);
	 * Q_ASSERT(array.count() == array.size());
	 * @endcode
	 */
	qsizetype count() const noexcept;

	/**
	 * @brief Checks if the array contains no elements.
	 *
	 * Returns true if the array has zero elements, false otherwise.
	 * This is a convenience method equivalent to size() == 0 but
	 * with more expressive semantics.
	 *
	 * @return true if array is empty, false otherwise
	 *
	 * @complexity O(1) - Constant time check
	 * @exception noexcept guarantee
	 *
	 * @note Equivalent to size() == 0
	 * @note More expressive than size comparison
	 * @note Useful for conditional logic
	 *
	 * @example
	 * @code
	 * QTomlArray array;
	 * Q_ASSERT(array.isEmpty());
	 *
	 * array.append(QTomlValue("data"));
	 * Q_ASSERT(!array.isEmpty());
	 * @endcode
	 */
	bool isEmpty() const noexcept;

	// ==================== Iterator Interface ====================

	/**
	 * @brief Returns a mutable iterator to the first element.
	 *
	 * Returns an iterator pointing to the first element of the array.
	 * The iterator can be used to traverse and modify array elements.
	 * For empty arrays, returns the same value as end().
	 *
	 * @return Mutable iterator to the first element
	 *
	 * @complexity O(1) - Constant time iterator creation
	 * @exception noexcept guarantee
	 *
	 * @note For empty arrays, begin() == end()
	 * @note Iterator is invalidated by capacity-changing operations
	 * @note Supports all random access iterator operations
	 *
	 * @example
	 * @code
	 * QTomlArray array{"a", "b", "c"};
	 *
	 * for (auto it = array.begin(); it != array.end(); ++it) {
	 *     qDebug() << it->toString();
	 * }
	 * @endcode
	 */
	iterator begin() noexcept;

	/**
	 * @brief Returns a const iterator to the first element.
	 *
	 * Returns a const iterator pointing to the first element of the array.
	 * The iterator can be used for read-only traversal of array elements.
	 * For empty arrays, returns the same value as end().
	 *
	 * @return Const iterator to the first element
	 *
	 * @complexity O(1) - Constant time iterator creation
	 * @exception noexcept guarantee
	 *
	 * @note For empty arrays, begin() == end()
	 * @note Safe for use with const arrays
	 * @note Elements cannot be modified through this iterator
	 */
	const_iterator begin() const noexcept;

	/**
	 * @brief Returns a const iterator to the first element (explicit const).
	 *
	 * Returns a const iterator pointing to the first element of the array.
	 * This method is explicitly const and always returns a const iterator,
	 * regardless of the const-ness of the array object.
	 *
	 * @return Const iterator to the first element
	 *
	 * @complexity O(1) - Constant time iterator creation
	 * @exception noexcept guarantee
	 *
	 * @note Always returns const iterator
	 * @note Useful when const iteration is specifically desired
	 * @note Consistent with Qt container conventions
	 */
	const_iterator constBegin() const noexcept;

	/**
	 * @brief Returns a mutable iterator to one past the last element.
	 *
	 * Returns an iterator pointing to one position past the last element
	 * of the array. This iterator serves as the end marker for iteration
	 * and should not be dereferenced.
	 *
	 * @return Mutable iterator to one past the last element
	 *
	 * @complexity O(1) - Constant time iterator creation
	 * @exception noexcept guarantee
	 *
	 * @note Should not be dereferenced
	 * @note Used as end marker for iteration
	 * @note For empty arrays, end() == begin()
	 */
	iterator end() noexcept;

	/**
	 * @brief Returns a const iterator to one past the last element.
	 *
	 * Returns a const iterator pointing to one position past the last element
	 * of the array. This iterator serves as the end marker for read-only
	 * iteration and should not be dereferenced.
	 *
	 * @return Const iterator to one past the last element
	 *
	 * @complexity O(1) - Constant time iterator creation
	 * @exception noexcept guarantee
	 *
	 * @note Should not be dereferenced
	 * @note Safe for use with const arrays
	 * @note Used as end marker for const iteration
	 */
	const_iterator end() const noexcept;

	/**
	 * @brief Returns a const iterator to one past the last element (explicit const).
	 *
	 * Returns a const iterator pointing to one position past the last element
	 * of the array. This method is explicitly const and always returns a
	 * const iterator, regardless of the const-ness of the array object.
	 *
	 * @return Const iterator to one past the last element
	 *
	 * @complexity O(1) - Constant time iterator creation
	 * @exception noexcept guarantee
	 *
	 * @note Always returns const iterator
	 * @note Should not be dereferenced
	 * @note Consistent with Qt container conventions
	 */
	const_iterator constEnd() const noexcept;

	// ==================== Type Conversion ====================

	/**
	 * @brief Converts the array to a QVariantList for Qt integration.
	 *
	 * Creates a QVariantList containing all array elements converted to
	 * QVariant objects. This enables integration with Qt APIs that expect
	 * QVariantList parameters or return values.
	 *
	 * @return QVariantList containing converted array elements
	 *
	 * @complexity O(n) where n is the number of elements
	 * @exception Strong exception safety guarantee
	 *
	 * @note All elements are converted to QVariant
	 * @note Nested arrays and tables are recursively converted
	 * @note Useful for Qt API integration and serialization
	 *
	 * @example
	 * @code
	 * QTomlArray array{"hello", 42, true};
	 * QVariantList variantList = array.toVariantList();
	 *
	 * Q_ASSERT(variantList.size() == 3);
	 * Q_ASSERT(variantList[0].toString() == "hello");
	 * Q_ASSERT(variantList[1].toInt() == 42);
	 * Q_ASSERT(variantList[2].toBool() == true);
	 * @endcode
	 */
	QVariantList toVariantList() const;

	/**
	 * @brief Creates a QTomlArray from a QVariantList.
	 *
	 * Converts a QVariantList to a QTomlArray by converting each QVariant
	 * element to a QTomlValue. This enables creation of TOML arrays from
	 * existing Qt data structures.
	 *
	 * @param list The QVariantList to convert
	 * @return QTomlArray containing converted elements
	 *
	 * @complexity O(n) where n is the number of elements in the list
	 * @exception Strong exception safety guarantee
	 *
	 * @note All QVariant elements are converted to QTomlValue
	 * @note Nested QVariantList and QVariantMap are recursively converted
	 * @note Static method for convenient conversion
	 * @note Invalid QVariant elements may result in null QTomlValue objects
	 *
	 * @example
	 * @code
	 * QVariantList variantList;
	 * variantList << "string" << 123 << false;
	 *
	 * QTomlArray array = QTomlArray::fromVariantList(variantList);
	 * Q_ASSERT(array.size() == 3);
	 * Q_ASSERT(array.at(0).toString() == "string");
	 * Q_ASSERT(array.at(1).toInteger() == 123);
	 * Q_ASSERT(array.at(2).toBool() == false);
	 * @endcode
	 *
	 * @see toVariantList() for reverse conversion
	 */
	static QTomlArray fromVariantList(const QVariantList& list);

	static QTomlArray fromStringList(const QStringList& list);

	QStringList toStringList() const;

private:
	/**
	 * @brief Private implementation pointer (PIMPL pattern).
	 *
	 * Pointer to private implementation containing all array data and
	 * internal state. Provides binary compatibility, compilation hiding,
	 * and efficient memory management through std::unique_ptr.
	 *
	 * Contains:
	 * - Dynamic array storage (QVector<QTomlValue>)
	 * - Capacity management and allocation strategy
	 * - Internal optimizations and caching
	 *
	 * @note Uses std::unique_ptr for automatic memory management
	 * @note Enables binary compatibility across library versions
	 * @note Hides implementation details from client code
	 *
	 * @see QTomlArrayPrivate for implementation details
	 */
	std::unique_ptr<class QTomlArrayPrivate> d_ptr;
};

/**
 * @brief Qt Meta-Object System registration for QTomlArray.
 *
 * Registers QTomlArray with Qt's type system, enabling use in QVariant
 * containers, signal/slot connections, and property systems. Essential
 * for full integration with Qt's reflection and serialization systems.
 *
 * Enables:
 * - QVariant::fromValue<QTomlArray>() and QVariant::value<QTomlArray>()
 * - Signal/slot parameters using QTomlArray
 * - Q_PROPERTY declarations with QTomlArray
 * - Integration with Qt's debugging and logging systems
 * - Serialization through Qt's property system
 *
 * @note Registration occurs automatically during static initialization
 * @note Required for full Qt integration and QVariant support
 * @see QMetaType for more information about Qt's type system
 */
Q_DECLARE_METATYPE(QTomlArray)