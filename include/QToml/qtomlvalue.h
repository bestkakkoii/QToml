/*
 * MIT License
 *
 * Copyright (c) 2025 QToml Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Project Information:
 * - Generated by: Claude 4.0 Sonnet (Anthropic AI) on 2025-08-30
 * - Verified and reviewed by: Bestkakkoii
 * - Original project structure and implementation concepts
 * - Built upon toml++ library (https://github.com/marzer/tomlplusplus)
 * - Qt framework integration and wrapper implementation
 */

#pragma once
#pragma execution_character_set("utf-8")

#include <QObject>
#include <QtGlobal>
#include <QString>
#include <QVariant>
#include <memory>

 // Forward declarations
class QTomlArray;
class QTomlObject;
class QTomlDateTime;

/**
 * @class QTomlValue
 * @brief Encapsulates a TOML value supporting unified representation of all TOML data types.
 *
 * QTomlValue is the core class of the QToml library, implementing the Variant Pattern
 * to represent all data types defined in the TOML specification. This design provides
 * great flexibility and type safety when parsing and manipulating TOML documents.
 *
 * The class uses std::variant as the internal storage mechanism, combined with the
 * PIMPL pattern implementation, providing type-safe runtime polymorphism while
 * maintaining good performance and binary compatibility.
 *
 * Supported TOML data types include:
 * - Null: Empty value (not actually present in TOML, but used for undefined states)
 * - Bool: Boolean values (true/false)
 * - Integer: 64-bit signed integers
 * - Double: Double-precision floating-point numbers (supports inf, -inf, nan)
 * - String: UTF-8 strings
 * - DateTime: Date-time values (supports date-only, time-only, full date-time)
 * - Array: Arrays (can contain heterogeneous elements)
 * - Hash: Tables/objects (key-value pair collections)
 * - Undefined: Undefined value (used for error handling)
 *
 * The interface design follows Qt style and maintains high consistency with QJsonValue,
 * making it easy for developers familiar with Qt development to quickly get started.
 *
 * @note All type checking and conversions are runtime-safe and will not produce undefined behavior
 * @note Supports implicit type conversion (such as Integer to Double), but preserves original type information
 * @see QTomlArray, QTomlObject, QTomlDateTime, QTomlDocument
 *
 * @example
 * @code
 * // Create values of different types
 * QTomlValue nullVal;                          // Null
 * QTomlValue boolVal(true);                    // Bool
 * QTomlValue intVal(42);                       // Integer
 * QTomlValue doubleVal(3.14);                  // Double
 * QTomlValue stringVal("Hello, TOML!");        // String
 * QTomlValue arrayVal(QTomlArray{...});        // Array
 * QTomlValue hashVal(QTomlObject{...});          // Hash
 *
 * // Type checking and safe conversion
 * if (intVal.isInteger()) {
 *     qint64 value = intVal.toInteger();
 *     double asDouble = intVal.toDouble();     // Implicit conversion
 * }
 *
 * // Use move semantics for performance optimization
 * QString largeString = generateLargeString();
 * QTomlValue efficientVal(std::move(largeString));  // Avoid copying
 * @endcode
 */
class Q_CORE_EXPORT QTomlValue
{
	Q_GADGET
public:
	/**
	 * @enum Type
	 * @brief Defines all data types that QTomlValue can hold.
	 *
	 * Each enumeration value corresponds to a data type in the TOML specification,
	 * providing the foundation for runtime type identification and type safety.
	 *
	 * The numeric assignment of enumeration values has special meaning:
	 * - Positive values: Standard TOML types
	 * - 0: Null (special state)
	 * - Negative values: Error or undefined states
	 */
	enum Type
	{
		Null = 0,          ///< Null value, indicating uninitialized or explicitly set to empty state
		Bool,              ///< Boolean value, true or false
		Integer,           ///< 64-bit signed integer, range -2^63 to 2^63-1
		Double,            ///< Double-precision floating-point number, supports special values inf, -inf, nan
		String,            ///< UTF-8 encoded string, supports multiline and literal strings
		DateTime,          ///< Date-time value, supports multiple formats and time zones
		Array,             ///< Heterogeneous array, can contain elements of any type
		Hash,              ///< Key-value pair table, keys must be strings, values can be any type
		Undefined = -1     ///< Undefined value, usually indicates error state or result of invalid operation
	};
	Q_ENUM(Type);

	// ==================== Constructors ====================

	/**
	 * @brief Default constructor creating a value of specified type.
	 *
	 * Creates a default value according to the specified type:
	 * - Null: Maintains empty state
	 * - Bool: false
	 * - Integer: 0
	 * - Double: 0.0
	 * - String: Empty string
	 * - DateTime: Empty date-time
	 * - Array: Empty array
	 * - Hash: Empty table
	 * - Undefined: Undefined state
	 *
	 * @param type The value type to create, defaults to Null
	 *
	 * @note Marked as noexcept, time complexity is O(1)
	 * @note For container types (Array, Hash), creates empty containers
	 */
	QTomlValue(Type type = Null) noexcept;

	/**
	 * @brief Boolean value constructor.
	 *
	 * Creates a QTomlValue object containing a boolean value.
	 * Boolean values in TOML are represented as true or false (lowercase).
	 *
	 * @param b The boolean value to store
	 *
	 * @note Marked as noexcept, time complexity is O(1)
	 */
	QTomlValue(bool b) noexcept;

	/**
	 * @brief 32-bit integer constructor.
	 *
	 * Creates a QTomlValue object containing an integer value.
	 * 32-bit integers are automatically promoted to 64-bit storage to ensure no precision loss.
	 *
	 * @param v The 32-bit integer value to store
	 *
	 * @note Marked as noexcept, internally stored as qint64 type
	 */
	QTomlValue(int v) noexcept;

	/**
	 * @brief 64-bit integer constructor.
	 *
	 * Creates a QTomlValue object containing a 64-bit integer value.
	 * This is the precision recommended by the TOML specification for representing
	 * sufficiently large numeric ranges.
	 *
	 * @param v The 64-bit integer value to store
	 *
	 * @note Marked as noexcept, stored directly without type conversion
	 */
	QTomlValue(qint64 v) noexcept;

	/**
	 * @brief Double-precision floating-point constructor.
	 *
	 * Creates a QTomlValue object containing a double-precision floating-point number.
	 * Supports all legal IEEE 754 values, including positive infinity, negative infinity, and NaN.
	 *
	 * @param v The double-precision floating-point value to store
	 *
	 * @note Marked as noexcept, supports special floating-point values
	 */
	QTomlValue(double v) noexcept;

	/**
	 * @brief C-style string constructor.
	 *
	 * Creates a QTomlValue object from a C-style string (null-terminated).
	 * The string is automatically converted to UTF-8 encoded QString for storage.
	 *
	 * @param s Pointer to the C-style string to store
	 *
	 * @note If s is nullptr, creates an empty string
	 * @note String copying occurs, time complexity is O(n)
	 */
	QTomlValue(const char* s);

	/**
	 * @brief QString constructor (copy version).
	 *
	 * Creates a QTomlValue from a QString object, copying the string content.
	 * Suitable for scenarios where the original string object needs to be preserved.
	 *
	 * @param s The QString object to copy
	 *
	 * @note String copying occurs, time complexity is O(n)
	 */
	QTomlValue(const QString& s);

	/**
	 * @brief QString constructor (move version).
	 *
	 * Creates a QTomlValue from a QString using move semantics, avoiding unnecessary copying.
	 * The source string object becomes an empty string after the move but remains valid.
	 *
	 * @param s The QString object to move (rvalue reference)
	 *
	 * @note Marked as noexcept, time complexity is O(1), high performance
	 * @note Suitable for temporary objects or scenarios where ownership transfer is explicit
	 */
	QTomlValue(QString&& s) noexcept;

	/**
	 * @brief QTomlArray constructor (copy version).
	 *
	 * Creates a QTomlValue from a QTomlArray object, performing a deep copy of the array content.
	 * The created QTomlValue type is Array.
	 *
	 * @param a The QTomlArray object to copy
	 *
	 * @note Time complexity is O(n), where n is the array size
	 */
	QTomlValue(const QTomlArray& a);

	/**
	 * @brief QTomlArray constructor (move version).
	 *
	 * Creates a QTomlValue from a QTomlArray using move semantics, avoiding deep copying.
	 * The source array object becomes an empty array after the move but remains valid.
	 *
	 * @param a The QTomlArray object to move (rvalue reference)
	 *
	 * @note Marked as noexcept, time complexity is O(1), high performance
	 */
	QTomlValue(QTomlArray&& a) noexcept;

	/**
	 * @brief QTomlObject constructor (copy version).
	 *
	 * Creates a QTomlValue from a QTomlObject object, performing a deep copy of the table content.
	 * The created QTomlValue type is Hash.
	 *
	 * @param h The QTomlObject object to copy
	 *
	 * @note Time complexity is O(n), where n is the number of key-value pairs in the table
	 */
	QTomlValue(const QTomlObject& h);

	/**
	 * @brief QTomlObject constructor (move version).
	 *
	 * Creates a QTomlValue from a QTomlObject using move semantics, avoiding deep copying.
	 * The source table object becomes an empty table after the move but remains valid.
	 *
	 * @param h The QTomlObject object to move (rvalue reference)
	 *
	 * @note Marked as noexcept, time complexity is O(1), high performance
	 */
	QTomlValue(QTomlObject&& h) noexcept;

	/**
	 * @brief QTomlDateTime constructor.
	 *
	 * Creates a QTomlValue from a QTomlDateTime object.
	 * The created QTomlValue type is DateTime.
	 *
	 * @param dt The QTomlDateTime object to store
	 *
	 * @note QTomlDateTime is a value type with relatively low copying cost
	 */
	QTomlValue(const QTomlDateTime& dt);

	/**
	 * @brief Copy constructor.
	 *
	 * Creates a deep copy of another QTomlValue object.
	 * Uses the PIMPL pattern to ensure completely independent copying.
	 *
	 * @param other The source object to copy
	 *
	 * @note Time complexity depends on the stored value type
	 */
	QTomlValue(const QTomlValue& other);

	/**
	 * @brief Move constructor.
	 *
	 * Efficiently transfers ownership of another QTomlValue object.
	 * The source object becomes Null state after the move but remains valid.
	 *
	 * @param other The source object to move (rvalue reference)
	 *
	 * @note Marked as noexcept, time complexity is O(1)
	 */
	QTomlValue(QTomlValue&& other) noexcept;

	/**
	 * @brief Destructor.
	 *
	 * Automatically cleans up all allocated resources using RAII principles.
	 * The PIMPL implementation ensures proper resource management.
	 *
	 * @note Marked as noexcept to guarantee no exceptions are thrown during destruction
	 */
	virtual ~QTomlValue() noexcept;

	/**
	 * @brief Copy assignment operator.
	 *
	 * Copies the content of another QTomlValue object to the current object.
	 * Includes self-assignment checking to ensure operation safety.
	 *
	 * @param other The source object to copy
	 * @return Reference to the current object, supporting chained assignment
	 *
	 * @note Time complexity depends on the stored value type
	 */
	QTomlValue& operator=(const QTomlValue& other);

	/**
	 * @brief Move assignment operator.
	 *
	 * Efficiently transfers ownership of another QTomlValue object.
	 * The original content of the current object is automatically cleaned up.
	 *
	 * @param other The source object to move (rvalue reference)
	 * @return Reference to the current object, supporting chained assignment
	 *
	 * @note Marked as noexcept, time complexity is O(1)
	 */
	QTomlValue& operator=(QTomlValue&& other) noexcept;

	// ==================== Type Checking Methods ====================

	/**
	 * @brief Checks if the value is of array type.
	 *
	 * @return true if the value type is Array, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @see toArray()
	 */
	bool isArray() const noexcept;

	/**
	 * @brief Checks if the value is of boolean type.
	 *
	 * @return true if the value type is Bool, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @see toBool()
	 */
	bool isBool() const noexcept;

	/**
	 * @brief Checks if the value is of double-precision floating-point type.
	 *
	 * @return true if the value type is Double, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @see toDouble()
	 */
	bool isDouble() const noexcept;

	/**
	 * @brief Checks if the value is of integer type.
	 *
	 * @return true if the value type is Integer, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @see toInteger()
	 */
	bool isInteger() const noexcept;

	/**
	 * @brief Checks if the value is of null type.
	 *
	 * @return true if the value type is Null, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 */
	bool isNull() const noexcept;

	/**
	 * @brief Checks if the value is of hash/table type.
	 *
	 * @return true if the value type is Hash, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @see toHash()
	 */
	bool isHash() const noexcept;

	/**
	 * @brief Checks if the value is of string type.
	 *
	 * @return true if the value type is String, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @see toString()
	 */
	bool isString() const noexcept;

	/**
	 * @brief Checks if the value is of date-time type.
	 *
	 * @return true if the value type is DateTime, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @see toDateTime()
	 */
	bool isDateTime() const noexcept;

	/**
	 * @brief Checks if the value is of undefined type.
	 *
	 * @return true if the value type is Undefined, false otherwise
	 * @note Marked as noexcept, time complexity is O(1)
	 * @note Undefined values usually indicate error states or results of invalid operations
	 */
	bool isUndefined() const noexcept;

	// ==================== Type Conversion Methods ====================

	/**
	 * @brief Converts the value to QTomlArray.
	 *
	 * If the current value is of Array type, returns its array content;
	 * otherwise returns an empty QTomlArray object.
	 *
	 * @return QTomlArray object, empty array if type mismatch
	 *
	 * @note Only returns valid content when isArray() returns true
	 * @note Returns a copy, modifications will not affect the original object
	 * @see isArray()
	 */
	QTomlArray toArray() const;

	/**
	 * @brief Converts the value to boolean.
	 *
	 * If the current value is of Bool type, returns its boolean value;
	 * otherwise returns the specified default value. No implicit type conversion is performed.
	 *
	 * @param defaultValue Default return value when type mismatch occurs
	 * @return Boolean value, returns default value if type mismatch
	 *
	 * @note Marked as noexcept, only Bool type returns actual value
	 * @note Will not convert numeric 0/1 or strings "true"/"false" to boolean values
	 * @see isBool()
	 */
	bool toBool(bool defaultValue = false) const noexcept;

	/**
	 * @brief Converts the value to double-precision floating-point number.
	 *
	 * If the current value is of Double type, directly returns its value;
	 * if it's of Integer type, automatically converts to double (possible precision loss);
	 * otherwise returns the specified default value.
	 *
	 * @param defaultValue Default return value when type mismatch occurs
	 * @return Double-precision floating-point number, supports implicit conversion from integer
	 *
	 * @note Marked as noexcept, supports safe conversion from Integer to Double
	 * @note Converting large integers may result in precision loss (beyond 2^53)
	 * @see isDouble(), isInteger()
	 */
	double toDouble(double defaultValue = 0.0) const noexcept;

	/**
	 * @brief Converts the value to 64-bit integer.
	 *
	 * If the current value is of Integer type, directly returns its value;
	 * if it's of Double type, performs truncation conversion (discards fractional part);
	 * otherwise returns the specified default value.
	 *
	 * @param defaultValue Default return value when type mismatch occurs
	 * @return 64-bit integer, supports truncation conversion from floating-point
	 *
	 * @note Marked as noexcept, supports truncation conversion from Double to Integer
	 * @note Converting floating-point numbers discards the fractional part, no rounding is performed
	 * @note Conversion result is undefined for floating-point numbers outside integer range
	 * @see isInteger(), isDouble()
	 */
	qint64 toInteger(qint64 defaultValue = 0) const noexcept;

	/**
	 * @brief Converts the value to QTomlObject.
	 *
	 * If the current value is of Hash type, returns its table content;
	 * otherwise returns an empty QTomlObject object.
	 *
	 * @return QTomlObject object, empty table if type mismatch
	 *
	 * @note Only returns valid content when isHash() returns true
	 * @note Returns a copy, modifications will not affect the original object
	 * @see isHash()
	 */
	QTomlObject toHash() const;

	/**
	 * @brief Converts the value to QTomlDateTime.
	 *
	 * If the current value is of DateTime type, returns its date-time content;
	 * otherwise returns an empty QTomlDateTime object.
	 *
	 * @return QTomlDateTime object, empty date-time if type mismatch
	 *
	 * @note Only returns valid content when isDateTime() returns true
	 * @see isDateTime()
	 */
	QTomlDateTime toDateTime() const;

	/**
	 * @brief Converts the value to QString.
	 *
	 * If the current value is of String type, returns its string content;
	 * otherwise returns an empty QString object. No stringification of other types is performed.
	 *
	 * @return QString object, empty string if type mismatch
	 *
	 * @note Only returns valid content when isString() returns true
	 * @note Will not convert numbers or other types to string representation
	 * @see isString()
	 */
	QString toString() const;

	/**
	 * @brief Converts the value to QVariant.
	 *
	 * Converts QTomlValue to the corresponding QVariant object for interaction with other Qt APIs.
	 * Conversion rules are as follows:
	 * - Null/Undefined → QVariant() (invalid variant)
	 * - Bool → QVariant(bool)
	 * - Integer → QVariant(qint64)
	 * - Double → QVariant(double)
	 * - String → QVariant(QString)
	 * - DateTime → QVariant::fromValue(QTomlDateTime)
	 * - Array → QVariant::fromValue(QTomlArray)
	 * - Hash → QVariant::fromValue(QTomlObject)
	 *
	 * @return Corresponding QVariant object
	 *
	 * @note Uses std::visit for efficient type dispatching
	 * @note Complex types (DateTime, Array, Hash) are wrapped using QVariant::fromValue
	 * @see QVariant::fromValue(), Q_DECLARE_METATYPE
	 *
	 * @example
	 * @code
	 * QTomlValue intVal(42);
	 * QVariant var = intVal.toVariant();
	 * Q_ASSERT(var.type() == QVariant::LongLong);
	 * Q_ASSERT(var.toLongLong() == 42);
	 * @endcode
	 */
	QVariant toVariant() const;

	/**
	 * @brief Gets the type of the value.
	 *
	 * Returns the actual type of the current value for runtime type checking and branching.
	 *
	 * @return Type enumeration value representing the currently stored data type
	 *
	 * @note Marked as noexcept, time complexity is O(1)
	 * @note Can be used in switch statements for type dispatching
	 *
	 * @example
	 * @code
	 * QTomlValue value(42);
	 * switch (value.type()) {
	 *     case QTomlValue::Integer:
	 *         qDebug() << "Integer value:" << value.toInteger();
	 *         break;
	 *     case QTomlValue::String:
	 *         qDebug() << "String value:" << value.toString();
	 *         break;
	 *     // ... other types
	 * }
	 * @endcode
	 */
	Type type() const noexcept;

	/**
	 * @brief Swaps content with another QTomlValue object.
	 *
	 * Efficiently swaps the content of two QTomlValue objects without copying operations.
	 * Uses smart pointer swap implementation to guarantee exception safety.
	 *
	 * @param other The other object to swap content with
	 *
	 * @note Marked as noexcept, time complexity is O(1)
	 * @note After swapping, both objects' types and values are exchanged
	 * @note Suitable for scenarios requiring efficient move semantics
	 *
	 * @example
	 * @code
	 * QTomlValue val1(42);
	 * QTomlValue val2("hello");
	 * val1.swap(val2);
	 * // Now val1 contains "hello", val2 contains 42
	 * @endcode
	 */
	void swap(QTomlValue& other) noexcept;

private:
	/**
	 * @brief Internal converter friend class for TOML document parsing.
	 *
	 * Allows the parser to directly access private members of QTomlValue,
	 * improving parsing performance and avoiding unnecessary public interface exposure.
	 */
	friend class QTomlPrivateConverter;

	/**
	 * @brief QTomlArray friend class allowing array operations on QTomlValue.
	 *
	 * Enables QTomlArray to efficiently manage its elements,
	 * avoiding performance overhead through public interfaces.
	 */
	friend class QTomlArray;

	/**
	 * @brief QTomlObject friend class allowing table operations on QTomlValue.
	 *
	 * Enables QTomlObject to efficiently manage its values,
	 * avoiding performance overhead through public interfaces.
	 */
	friend class QTomlObject;

	/**
	 * @brief PIMPL pattern private implementation pointer.
	 *
	 * Uses smart pointer to manage private implementation, providing:
	 * - Binary compatibility: Header file modifications don't affect compiled code
	 * - Compilation hiding: Implementation details not exposed in header files
	 * - Exception safety: Automatic resource management
	 * - Performance optimization: Avoids including numerous dependencies in header files
	 *
	 * Internally uses std::variant to store different types of values,
	 * providing type-safe runtime polymorphism.
	 */
	std::unique_ptr<class QTomlValuePrivate> d_ptr;
};

Q_DECLARE_METATYPE(QTomlValue)