/*
 * MIT License
 *
 * Copyright (c) 2025 QToml Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Project Information:
 * - Generated by: Claude 4.0 Sonnet (Anthropic AI) on 2025-08-30
 * - Verified and reviewed by: Bestkakkoii
 * - Original project structure and implementation concepts
 * - Built upon toml++ library (https://github.com/marzer/tomlplusplus)
 * - Qt framework integration and wrapper implementation
 */

 /**
  * @file qtomldocument.h
  * @brief Declaration of QTomlDocument class providing top-level interface for TOML document operations.
  *
  * This header defines the QTomlDocument class, which serves as the primary entry point
  * for the QToml library. It provides comprehensive functionality for parsing, manipulating,
  * and serializing TOML documents according to the TOML v1.0.0 specification.
  *
  * The QTomlDocument class encapsulates complete TOML document structures and provides
  * standard interfaces for external data exchange. Following TOML specification requirements,
  * every TOML document must have a root table, which is represented internally using QTomlObject.
  *
  * Key features:
  * - TOML parsing: Convert UTF-8 encoded TOML text to structured data
  * - TOML serialization: Convert structured data to TOML-compliant text
  * - Error handling: Detailed parsing error information with location data
  * - Data validation: Ensure compliance with TOML specification requirements
  * - Type conversion: Bidirectional conversion with QVariant for Qt integration
  * - Memory management: RAII principles with smart pointer resource safety
  *
  * The implementation uses the PIMPL pattern for binary compatibility and improved
  * compilation performance. Internally, it integrates the high-performance toml++
  * parser to provide robust TOML processing capabilities.
  *
  * Interface design follows QJsonDocument patterns for familiarity with Qt developers,
  * while being optimized and extended for TOML-specific features.
  *
  * Design principles:
  * - **Standards Compliance**: Full adherence to TOML v1.0.0 specification
  * - **Performance**: Optimized parsing and serialization with minimal overhead
  * - **Safety**: Exception-safe operations with strong guarantees
  * - **Integration**: Seamless interoperability with Qt ecosystem
  * - **Usability**: Intuitive API following Qt conventions
  *
  * Thread safety:
  * - Parsing operations are thread-safe (static methods)
  * - Individual document objects require external synchronization
  * - Copy construction is thread-safe with proper synchronization
  * - Immutable operations can be safely called from multiple threads
  *
  * @note All TOML documents must have a root table; empty documents are represented as empty QTomlObject
  * @note Supports all TOML v1.0.0 specification features including complex nested structures
  * @note Parsing operations are thread-safe, but individual objects should not be shared between threads
  * @see QTomlObject, QTomlParseError, QTomlValue
  * @see https://toml.io/en/v1.0.0 for TOML specification details
  */

#pragma once
#pragma execution_character_set("utf-8")

#include <QObject>
#include <QtGlobal>
#include <QByteArray>
#include <QVariant>
#include <QLatin1StringView>
#include <QStringView>
#include <memory>

// Forward declarations
class QTomlObject;
class QTomlArray;
class QTomlParseError;

// Must include full definition for return values
#include "qtomlvalue.h"

/**
 * @class QTomlDocument
 * @brief Provides top-level interface for reading and writing TOML documents as the main entry point for QToml library.
 *
 * QTomlDocument is the core class of the QToml library, responsible for complete TOML document
 * parsing, serialization, and management. It encapsulates full TOML document structures and
 * provides standard interfaces for external data exchange.
 *
 * According to TOML specification, every TOML document's root element must be a table,
 * therefore QTomlDocument uses QTomlObject internally to represent the document's root structure.
 * This design ensures complete compatibility with TOML specification requirements.
 *
 * Main feature set:
 * - **TOML Parsing**: Parse UTF-8 encoded TOML text into structured data
 * - **TOML Serialization**: Convert structured data to specification-compliant TOML text
 * - **Error Handling**: Provide detailed parsing error information including position and description
 * - **Data Validation**: Ensure data structures comply with TOML specification requirements
 * - **Type Conversion**: Support bidirectional conversion with QVariant for Qt integration
 * - **Memory Management**: Use RAII and smart pointers to ensure resource safety
 *
 * The class uses PIMPL pattern design to provide binary compatibility and better compilation performance.
 * Internally it integrates the toml++ parser to provide high-performance TOML processing capabilities.
 *
 * Interface design maintains consistency with QJsonDocument for easy adoption by Qt developers,
 * while being optimized and extended for TOML-specific characteristics.
 *
 * Design principles:
 * - **Standards Compliance**: Full adherence to TOML v1.0.0 specification
 * - **Performance**: Optimized parsing and serialization with minimal overhead
 * - **Safety**: Exception-safe operations with strong guarantees
 * - **Integration**: Seamless interoperability with Qt ecosystem
 * - **Usability**: Intuitive API following Qt conventions
 *
 * Thread safety:
 * - Parsing operations are thread-safe (static methods)
 * - Individual document objects require external synchronization
 * - Copy construction is thread-safe with proper synchronization
 * - Immutable operations can be safely called from multiple threads
 *
 * @note All TOML documents must have a root table; empty documents are represented as empty QTomlObject
 * @note Supports all TOML v1.0.0 specification features including complex nested structures
 * @note Parsing process is thread-safe, but individual objects should not be shared between threads
 * @see QTomlObject, QTomlParseError, QTomlValue
 *
 * @example Basic usage:
 * @code
 * // Parse TOML string
 * QByteArray tomlData = R"(
 *     [database]
 *     host = "localhost"
 *     port = 5432
 *     ssl = true
 * )";
 *
 * QTomlParseError error;
 * QTomlDocument doc = QTomlDocument::fromToml(tomlData, &error);
 * if (error.hasError()) {
 *     qWarning() << "Parse error:" << error.errorString();
 *     return;
 * }
 *
 * // Access data
 * QTomlObject root = doc.object();
 * QTomlObject database = root["database"].toObject();
 * QString host = database["host"].toString();
 * int port = database["port"].toInteger();
 *
 * // Modify and serialize
 * database.insert("timeout", QTomlValue(30));
 * root.insert("database", QTomlValue(database));
 * doc.setHash(root);
 *
 * QByteArray output = doc.toToml();
 * qDebug() << "Generated TOML:" << output;
 * @endcode
 */
class Q_CORE_EXPORT QTomlDocument
{
	Q_GADGET
public:
	// ==================== Construction and Destruction ====================

	/**
	 * @brief Default constructor creating an empty TOML document.
	 *
	 * Creates an object representing an empty TOML document. The empty document contains
	 * an empty root table (QTomlObject) internally, with isNull() returning true and
	 * isEmpty() also returning true.
	 *
	 * Empty documents are valid TOML documents and can be serialized to empty strings
	 * or strings containing only comments.
	 *
	 * @complexity O(1) - Constant time complexity
	 * @exception noexcept guarantee
	 *
	 * @note Marked noexcept for optimal performance
	 * @note Empty documents can be populated via setHash() to become non-empty
	 * @note Default state allows immediate use without additional initialization
	 *
	 * @example
	 * @code
	 * QTomlDocument doc;                   // Empty document
	 * Q_ASSERT(doc.isNull());             // Verify null state
	 * Q_ASSERT(doc.isEmpty());            // Verify empty state
	 *
	 * // Document is ready for use
	 * QTomlObject config;
	 * config.insert("version", QTomlValue("1.0"));
	 * doc.setHash(config);                // Now populated
	 * Q_ASSERT(!doc.isNull());            // No longer null
	 * @endcode
	 */
	QTomlDocument() noexcept;

	/**
	 * @brief Constructs TOML document from QTomlObject.
	 *
	 * Creates a TOML document using the given QTomlObject as the root table.
	 * This is the standard method for creating documents with initial content.
	 *
	 * The input object is copied into the document, so the original object
	 * remains unchanged and can be safely modified after construction.
	 *
	 * @param object The QTomlObject object to use as the document's root table
	 *
	 * @complexity O(n) where n is the number of elements in the object
	 * @exception Strong exception safety guarantee
	 *
	 * @note Input object is copied; original object remains unchanged
	 * @note If object is empty, created document isEmpty() returns true but isNull() returns false
	 * @note All nested structures are deep-copied for independence
	 *
	 * @example
	 * @code
	 * QTomlObject config;
	 * config.insert("version", QTomlValue("1.0.0"));
	 * config.insert("debug", QTomlValue(false));
	 *
	 * QTomlDocument doc(config);
	 * Q_ASSERT(!doc.isNull());            // Not null - contains data
	 * Q_ASSERT(doc.isObject());             // Contains valid table structure
	 *
	 * // Original object can be modified independently
	 * config.insert("new_key", QTomlValue("value"));
	 * Q_ASSERT(!doc.object().contains("new_key"));  // Document unchanged
	 * @endcode
	 */
	explicit QTomlDocument(const QTomlObject& object);

	/**
	 * @brief Copy constructor creating deep copy of another document.
	 *
	 * Creates a new QTomlDocument instance that is an exact copy of the source
	 * document, including the entire document structure and all nested data.
	 * Uses PIMPL pattern's deep copy semantics to ensure complete independence.
	 *
	 * @param other The source document object to copy from
	 *
	 * @complexity O(n) where n is the total number of elements in the document
	 * @exception Strong exception safety guarantee
	 *
	 * @note Creates completely independent copy
	 * @note All nested data structures are deep-copied
	 * @note Modifications to either document will not affect the other
	 *
	 * @example
	 * @code
	 * QTomlDocument original = QTomlDocument::fromToml(tomlData);
	 * QTomlDocument copy(original);
	 *
	 * // Verify independence
	 * QTomlObject copyRoot = copy.object();
	 * copyRoot.insert("new_item", QTomlValue(42));
	 * copy.setHash(copyRoot);
	 *
	 * Q_ASSERT(!original.object().contains("new_item"));  // Original unchanged
	 * Q_ASSERT(copy.object().contains("new_item"));       // Copy modified
	 * @endcode
	 */
	QTomlDocument(const QTomlDocument& other);

	/**
	 * @brief Move constructor for efficient transfer of document ownership.
	 *
	 * Creates a QTomlDocument instance by transferring ownership of another
	 * document's resources. The source document becomes empty but remains
	 * in a valid state after the move.
	 *
	 * Uses C++11 move semantics to transfer resources efficiently, avoiding
	 * unnecessary copying for temporary objects and return value optimization.
	 *
	 * @param other Rvalue reference to the source document object to move from
	 *
	 * @complexity O(1) - Constant time complexity
	 * @exception noexcept guarantee
	 *
	 * @note Source object remains valid but in unspecified state after move
	 * @note Enables return value optimization and efficient temporary handling
	 * @note Marked noexcept for optimal move semantics
	 *
	 * @example
	 * @code
	 * QTomlDocument createDocument() {
	 *     QTomlObject config;
	 *     config.insert("temp", QTomlValue("data"));
	 *     return QTomlDocument(config);  // Move constructor called
	 * }
	 *
	 * QTomlDocument doc = createDocument();  // Efficient transfer, no copying
	 * Q_ASSERT(!doc.isNull());              // Document received data
	 * @endcode
	 */
	QTomlDocument(QTomlDocument&& other) noexcept;

	/**
	 * @brief Destructor automatically cleaning all allocated resources.
	 *
	 * Automatically manages memory using RAII principles, requiring no manual cleanup.
	 * The PIMPL implementation ensures correct resource release and exception safety.
	 *
	 * @complexity O(n) where n is the number of elements requiring cleanup
	 * @exception noexcept guarantee
	 *
	 * @note Uses RAII for automatic resource management
	 * @note Guaranteed not to throw exceptions during destruction
	 * @note No manual cleanup required
	 */
	~QTomlDocument() noexcept;

	// ==================== Assignment Operations ====================

	/**
	 * @brief Copy assignment operator copying contents from another document.
	 *
	 * Performs deep copy operation, replacing current document contents with
	 * a copy of the source document's data. Includes self-assignment protection
	 * to ensure safety when a document is assigned to itself.
	 *
	 * If the target object already has content, it is cleaned up before copying.
	 * The operation is exception-safe and atomic.
	 *
	 * @param other The source document object to copy from
	 * @return Reference to this object for chaining assignments
	 *
	 * @complexity O(n) where n is the number of elements in source document
	 * @exception Strong exception safety guarantee
	 *
	 * @note Self-assignment (doc = doc) is handled safely
	 * @note Previous contents are automatically cleaned up
	 * @note Supports assignment chaining through reference return
	 *
	 * @example
	 * @code
	 * QTomlDocument doc1 = QTomlDocument::fromToml(data1);
	 * QTomlDocument doc2 = QTomlDocument::fromToml(data2);
	 * QTomlDocument doc3;
	 *
	 * // Assignment chain
	 * doc3 = doc2 = doc1;
	 * Q_ASSERT(doc3.toToml() == doc1.toToml());
	 *
	 * // Self-assignment safety
	 * doc1 = doc1;  // Safe, no-op due to self-assignment check
	 * @endcode
	 */
	QTomlDocument& operator=(const QTomlDocument& other);

	/**
	 * @brief Move assignment operator for efficient transfer of document ownership.
	 *
	 * Replaces current document contents by transferring ownership from another
	 * document's resources. The source document's resources are moved to this
	 * object while the current object's previous contents are automatically cleaned up.
	 *
	 * Uses move semantics to avoid unnecessary copying, providing optimal performance
	 * for temporary objects and return value optimization scenarios.
	 *
	 * @param other Rvalue reference to the source document object to move from
	 * @return Reference to this object for chaining assignments
	 *
	 * @complexity O(1) - Constant time complexity
	 * @exception noexcept guarantee
	 *
	 * @note Previous contents are automatically cleaned up
	 * @note Source object should not be used after the move
	 * @note Marked noexcept for optimal performance and exception safety
	 *
	 * @example
	 * @code
	 * QTomlDocument doc1 = QTomlDocument::fromToml(data1);
	 * QTomlDocument doc2;
	 *
	 * // Move assignment
	 * doc2 = std::move(doc1);
	 * Q_ASSERT(!doc2.isNull());  // doc2 now contains the data
	 * // doc1 is now in valid but unspecified state
	 *
	 * // Chain assignment with temporary
	 * QTomlDocument doc3;
	 * doc3 = QTomlDocument(someHash);  // Move assignment from temporary
	 * @endcode
	 */
	QTomlDocument& operator=(QTomlDocument&& other) noexcept;

	// ==================== Document State Queries ====================

	/**
	 * @brief Checks if document contains valid table structure.
	 *
	 * Determines whether the document contains a valid root table. Since all
	 * TOML document roots must be tables according to specification, this method
	 * is typically equivalent to !isNull().
	 *
	 * @return true if document contains valid table structure, false otherwise
	 *
	 * @complexity O(1) - Constant time complexity
	 * @exception noexcept guarantee
	 *
	 * @note Even empty tables return true as long as document is valid
	 * @note Consistent with TOML specification requiring root table
	 * @see isNull(), isEmpty()
	 *
	 * @example
	 * @code
	 * QTomlDocument doc;
	 * Q_ASSERT(!doc.isObject());            // Default construction is null
	 *
	 * QTomlObject emptyHash;
	 * doc.setHash(emptyHash);
	 * Q_ASSERT(doc.isObject());             // Now contains valid (empty) table
	 *
	 * QTomlDocument parsed = QTomlDocument::fromToml("key = 'value'");
	 * Q_ASSERT(parsed.isObject());          // Parsed document has valid table
	 * @endcode
	 */
	bool isObject() const noexcept;

	/**
	 * @brief Checks if document is empty (uninitialized state).
	 *
	 * Determines whether the document is in an uninitialized state, meaning
	 * it was default-constructed and has not been assigned any content.
	 * Empty documents cannot perform serialization operations until a root table is set.
	 *
	 * @return true if document is empty, false otherwise
	 *
	 * @complexity O(1) - Constant time complexity
	 * @exception noexcept guarantee
	 *
	 * @note Empty document is different from document containing empty table
	 * @note Null documents require setHash() call before serialization
	 * @see isEmpty(), isObject()
	 *
	 * @example
	 * @code
	 * QTomlDocument doc;
	 * Q_ASSERT(doc.isNull());             // Default construction is null
	 *
	 * QTomlObject emptyHash;
	 * doc.setHash(emptyHash);
	 * Q_ASSERT(!doc.isNull());            // No longer null (has empty table)
	 * Q_ASSERT(doc.isEmpty());            // But is empty (table has no content)
	 *
	 * QTomlParseError error;
	 * QTomlDocument parsed = QTomlDocument::fromToml("", &error);
	 * Q_ASSERT(!parsed.isNull());         // Successful parse is not null
	 * @endcode
	 */
	bool isNull() const noexcept;

	/**
	 * @brief Checks if document contains no data.
	 *
	 * Determines whether the document is empty or the root table contains no
	 * key-value pairs. This method combines isNull() checking with root table
	 * empty state verification.
	 *
	 * @return true if document is empty or root table is empty, false otherwise
	 *
	 * @complexity O(1) - Constant time complexity
	 * @exception noexcept guarantee
	 *
	 * @note Empty documents can be serialized to empty TOML strings
	 * @note Combines null state and content emptiness checking
	 * @see isNull(), isObject()
	 *
	 * @example
	 * @code
	 * QTomlDocument doc;
	 * Q_ASSERT(doc.isEmpty());            // Default construction is empty
	 *
	 * QTomlObject emptyHash;
	 * doc.setHash(emptyHash);
	 * Q_ASSERT(doc.isEmpty());            // Empty table is still empty
	 *
	 * QTomlObject filledHash;
	 * filledHash.insert("key", QTomlValue("value"));
	 * doc.setHash(filledHash);
	 * Q_ASSERT(!doc.isEmpty());           // Now contains data
	 * @endcode
	 */
	bool isEmpty() const noexcept;

	// ==================== Content Access and Modification ====================

	/**
	 * @brief Retrieves the document's root table.
	 *
	 * Returns a copy of the document's root table. The root table contains all
	 * top-level key-value pairs and serves as the primary entry point for
	 * accessing and modifying document content.
	 *
	 * @return Copy of document's root table as QTomlObject, or empty table if document is empty
	 *
	 * @complexity O(n) where n is the number of elements in the root table
	 * @exception Strong exception safety guarantee
	 *
	 * @note Returns a copy; modifications won't affect document's original content
	 * @note To modify document, modify returned table then call setHash()
	 * @see setHash()
	 *
	 * @example
	 * @code
	 * QTomlDocument doc = QTomlDocument::fromToml(tomlData);
	 * QTomlObject root = doc.object();
	 *
	 * // Modify content
	 * root.insert("new_key", QTomlValue("new_value"));
	 * doc.setHash(root);  // Apply modifications
	 *
	 * // Verify changes
	 * Q_ASSERT(doc.object().contains("new_key"));
	 * @endcode
	 */
	QTomlObject object() const;

	/**
	 * @brief Sets the document's root table.
	 *
	 * Sets the specified QTomlObject as the document's root table, replacing
	 * existing content. This is the standard method for modifying document content.
	 *
	 * The input object is copied into the document, so the original object
	 * remains unchanged and can be safely modified after this operation.
	 *
	 * @param object The new root table to set
	 *
	 * @complexity O(n) where n is the number of elements in the object
	 * @exception Strong exception safety guarantee
	 *
	 * @note Input object is copied; original object remains unchanged
	 * @note After setting, document becomes non-null (isNull() returns false)
	 * @note If empty table is passed, document becomes isEmpty() = true but still valid
	 * @see object()
	 *
	 * @example
	 * @code
	 * QTomlDocument doc;
	 * QTomlObject config;
	 * config.insert("app_name", QTomlValue("MyApp"));
	 *
	 * doc.setHash(config);  // Set document content
	 * Q_ASSERT(!doc.isNull());            // No longer null
	 * Q_ASSERT(!doc.isEmpty());           // Contains data
	 *
	 * // Original object can be modified independently
	 * config.clear();
	 * Q_ASSERT(!doc.isEmpty());           // Document unchanged
	 * @endcode
	 */
	void setHash(const QTomlObject& object);

	// ==================== TOML Parsing and Serialization ====================

	/**
	 * @brief Creates document by parsing TOML byte data.
	 *
	 * This is the primary method for parsing TOML text, supporting the complete
	 * TOML v1.0.0 specification. The parsing process uses the high-performance
	 * toml++ parser and provides detailed error reporting for parsing failures.
	 *
	 * Supported TOML features include:
	 * - All basic data types (strings, numbers, booleans, date-times)
	 * - Arrays and tables (including nested structures)
	 * - Inline tables and table arrays
	 * - Multi-line strings and literal strings
	 * - Scientific notation and special floating-point values (inf, nan)
	 * - Comments and whitespace handling
	 * - Unicode characters and escape sequences
	 *
	 * @param toml UTF-8 encoded byte array containing TOML text
	 * @param error Optional error object pointer for receiving detailed parsing error information
	 * @return Valid document object on successful parsing, null document on failure
	 *
	 * @complexity O(n) where n is the input length
	 * @exception Strong exception safety guarantee
	 *
	 * @note This is a static method for creating new document instances
	 * @note If parsing fails, returned document isNull() will be true
	 * @note error parameter can be nullptr if error information is not needed
	 * @note Input must be valid UTF-8 encoding; other encodings may cause parsing failure
	 *
	 * @example
	 * @code
	 * QByteArray tomlData = R"(
	 *     # Application configuration
	 *     title = "My Application"
	 *     version = "1.0.0"
	 *
	 *     [database]
	 *     host = "localhost"
	 *     port = 5432
	 *
	 *     [[servers]]
	 *     name = "alpha"
	 *     ip = "192.168.1.1"
	 * )";
	 *
	 * QTomlParseError error;
	 * QTomlDocument doc = QTomlDocument::fromToml(tomlData, &error);
	 *
	 * if (!error.hasError()) {
	 *     qDebug() << "Parsing successful";
	 *     // Use document data...
	 * } else {
	 *     qWarning() << "Parsing failed:" << error.errorString();
	 *     qWarning() << "Error location: line" << error.line << "column" << error.column;
	 * }
	 * @endcode
	 */
	static QTomlDocument fromToml(const QByteArray& toml, QTomlParseError* error = nullptr);

	/**
	 * @brief Serializes document to TOML format byte data.
	 *
	 * Converts the document's content to TOML specification-compliant text format.
	 * The serialization process automatically handles data type conversion, special
	 * character escaping, and formatting output details.
	 *
	 * Serialization features:
	 * - Automatic selection of optimal string quoting style (basic, literal, multi-line)
	 * - Intelligent table and array formatting for improved readability
	 * - Precision preservation avoiding floating-point precision loss
	 * - Correct handling of special floating-point values (inf, -inf, nan)
	 * - TOML v1.0.0 specification-compliant output format
	 * - UTF-8 encoding supporting all Unicode characters
	 *
	 * @return UTF-8 encoded byte array containing TOML text, empty array for empty documents
	 *
	 * @complexity O(n) where n is the total number of elements in the document
	 * @exception Strong exception safety guarantee
	 *
	 * @note If document is empty (isNull() is true), returns empty QByteArray
	 * @note Serialization errors are included as error comments in returned byte array
	 * @note Output is always valid UTF-8 encoding
	 *
	 * @example
	 * @code
	 * QTomlObject config;
	 * config.insert("app_name", QTomlValue("My App"));
	 * config.insert("debug", QTomlValue(true));
	 *
	 * QTomlObject database;
	 * database.insert("host", QTomlValue("localhost"));
	 * database.insert("port", QTomlValue(5432));
	 * config.insert("database", QTomlValue(database));
	 *
	 * QTomlDocument doc(config);
	 * QByteArray tomlOutput = doc.toToml();
	 *
	 * qDebug() << "Generated TOML:";
	 * qDebug() << tomlOutput;
	 *
	 * // Output similar to:
	 * // app_name = "My App"
	 * // debug = true
	 * //
	 * // [database]
	 * // host = "localhost"
	 * // port = 5432
	 * @endcode
	 */
	QByteArray toToml() const;

	// ==================== Qt Integration Methods ====================

	/**
	 * @brief Creates TOML document from QVariant.
	 *
	 * Attempts to convert a QVariant object to QTomlDocument. Supports the following conversions:
	 * - QVariant containing QTomlDocument: Direct extraction
	 * - QVariant containing QVariantMap: Convert to QTomlObject then create document
	 * - Other types: Return empty document
	 *
	 * This method facilitates data exchange with other Qt components, particularly
	 * integration with QSettings, QJsonDocument, and similar Qt APIs.
	 *
	 * @param variant The QVariant object to convert
	 * @return Converted document object, or empty document on failure
	 *
	 * @complexity Depends on variant data complexity; O(1) for direct extractions, O(n) for maps
	 * @exception Strong exception safety guarantee
	 *
	 * @note This is a static method; conversion failure does not throw exceptions
	 * @note For complex QVariantMap, conversion may not be completely accurate
	 * @note Time complexity depends on variant data complexity
	 * @see toVariant()
	 *
	 * @example
	 * @code
	 * // Create document from QVariantMap
	 * QVariantMap configMap = {
	 *     {"name", "MyApp"},
	 *     {"version", "1.0.0"},
	 *     {"debug", true}
	 * };
	 *
	 * QVariant variant = QVariant::fromValue(configMap);
	 * QTomlDocument doc = QTomlDocument::fromVariant(variant);
	 *
	 * if (!doc.isNull()) {
	 *     qDebug() << "Conversion successful";
	 * }
	 * @endcode
	 */
	static QTomlDocument fromVariant(const QVariant& variant);

	/**
	 * @brief Converts document to QVariant.
	 *
	 * Wraps document content as QVariant object for easy interaction with other Qt APIs.
	 * Conversion rules:
	 * - Empty document: Return invalid QVariant
	 * - Valid document: Convert root table to QVariant
	 *
	 * The returned QVariant can be used for:
	 * - Storage in Qt containers
	 * - Passing to signals and slots
	 * - QML interaction
	 * - Serialization to other formats
	 *
	 * @return QVariant object containing document data, or invalid QVariant for empty documents
	 *
	 * @complexity O(n) where n is the number of elements in the document
	 * @exception Strong exception safety guarantee
	 *
	 * @note Returned QVariant contains a copy of the root table
	 * @note Empty documents return invalid QVariant
	 * @see fromVariant()
	 *
	 * @example
	 * @code
	 * QTomlDocument doc = QTomlDocument::fromToml(tomlData);
	 * QVariant variant = doc.toVariant();
	 *
	 * // Can be stored in settings
	 * QSettings settings;
	 * settings.setValue("config", variant);
	 *
	 * // Or converted to other formats
	 * QJsonDocument jsonDoc = QJsonDocument::fromVariant(variant);
	 * @endcode
	 */
	QVariant toVariant() const;

	// ==================== Qt JSON API Compatibility Extensions ====================

	/**
	 * @brief TOML formatting options for serialization.
	 *
	 * Defines formatting styles for TOML output, similar to QJsonDocument::JsonFormat.
	 * Controls the formatting and spacing of the generated TOML text.
	 */
	enum TomlFormat {
		Indented,  ///< Human-readable format with proper indentation and spacing
		Compact    ///< Compact format with minimal whitespace
	};

	/**
	 * @brief Constructs TOML document from QTomlArray.
	 *
	 * Creates a TOML document with an array as the root element. While TOML
	 * specification normally requires tables as document roots, this constructor
	 * provides Qt JSON API compatibility for array-based documents.
	 *
	 * @param array The QTomlArray to use as the document's root element
	 *
	 * @note Provides Qt JSON API compatibility
	 * @note May not be valid according to strict TOML specification
	 * @see QTomlDocument(const QTomlObject&)
	 */
	explicit QTomlDocument(const QTomlArray& array);

	/**
	 * @brief Retrieves the document's root array.
	 *
	 * Returns the root array if the document contains an array, or an empty
	 * array if the document contains a table or is empty. This method provides
	 * Qt JSON API compatibility.
	 *
	 * @return Copy of document's root array, or empty array if not array-based
	 *
	 * @note Provides Qt JSON API compatibility
	 * @note Returns empty array for table-based documents
	 * @see setArray(), isArray()
	 */
	QTomlArray array() const;

	/**
	 * @brief Checks if document contains an array as root element.
	 *
	 * Returns true if the document's root element is an array, false if it's
	 * a table or the document is empty. This method provides Qt JSON API compatibility.
	 *
	 * @return true if document contains root array, false otherwise
	 *
	 * @note Provides Qt JSON API compatibility
	 * @note Complements isObject() for complete type checking
	 * @see isObject(), array()
	 */
	bool isArray() const noexcept;

	/**
	 * @brief Sets the document's root array.
	 *
	 * Sets the specified QTomlArray as the document's root element, replacing
	 * existing content. This method provides Qt JSON API compatibility.
	 *
	 * @param array The new root array to set
	 *
	 * @note Provides Qt JSON API compatibility
	 * @note After setting, document becomes non-null
	 * @note May not produce valid TOML according to strict specification
	 * @see array(), setHash()
	 */
	void setArray(const QTomlArray& array);

	/**
	 * @brief Serializes document to TOML format with formatting options.
	 *
	 * Enhanced version of toToml() that accepts formatting options to control
	 * the output style. This method provides Qt JSON API compatibility.
	 *
	 * @param format The formatting style to use (Indented or Compact)
	 * @return UTF-8 encoded byte array containing formatted TOML text
	 *
	 * @note Provides Qt JSON API compatibility
	 * @note Default toToml() method uses Indented format
	 * @see toToml()
	 */
	QByteArray toToml(TomlFormat format) const;

	/**
	 * @brief Checks if the document represents valid data.
	 *
	 * Returns true if the document contains valid data (either table or array),
	 * false if the document is in an undefined or invalid state.
	 *
	 * @return true if document is valid, false otherwise
	 *
	 * @note Qt class API consistency method
	 * @note Equivalent to !isNull() for documents
	 * @see isNull(), isEmpty()
	 */
	bool isValid() const noexcept;

	/**
	 * @brief Const subscript operator for object key access.
	 *
	 * If this document contains an object, returns the value associated with the key.
	 * If the key doesn't exist or this document is not an object, returns a null QTomlValue.
	 *
	 * @param key The key to look up in the object
	 * @return QTomlValue associated with the key, or null if not found or not an object
	 *
	 * @note Provides Qt JSON API compatibility
	 * @note Safe to use on array-based documents (returns null)
	 * @see isObject()
	 */
	const QTomlValue operator[](const QString& key) const;

	/**
	 * @brief Const subscript operator for array index access.
	 *
	 * If this document contains an array, returns the value at the specified index.
	 * If the index is out of bounds or this document is not an array, returns a null QTomlValue.
	 *
	 * @param i The index to access in the array
	 * @return QTomlValue at the specified index, or null if invalid index or not an array
	 *
	 * @note Provides Qt JSON API compatibility
	 * @note Safe to use on object-based documents (returns null)
	 * @see isArray()
	 */
	const QTomlValue operator[](qsizetype i) const;

	/**
	 * @brief Const subscript operator for object key access with QLatin1StringView.
	 *
	 * String view variant of operator[] for efficient key lookup without string conversion.
	 *
	 * @param key The key to look up (QLatin1StringView)
	 * @return QTomlValue associated with the key, or null if not found
	 */
	const QTomlValue operator[](QLatin1StringView key) const;

	/**
	 * @brief Const subscript operator for object key access with QStringView.
	 *
	 * String view variant of operator[] for efficient key lookup without string conversion.
	 *
	 * @param key The key to look up (QStringView)
	 * @return QTomlValue associated with the key, or null if not found
	 */
	const QTomlValue operator[](QStringView key) const;

	/**
	 * @brief Swaps content with another QTomlDocument object.
	 *
	 * Efficiently swaps the content of two QTomlDocument objects without copying.
	 * Uses smart pointer swap for optimal performance.
	 *
	 * @param other The other document to swap content with
	 *
	 * @note Marked noexcept for optimal performance
	 * @note Time complexity is O(1)
	 */
	void swap(QTomlDocument& other) noexcept;

private:
	/**
	 * @brief PIMPL pattern private implementation pointer.
	 *
	 * Uses smart pointer to manage private implementation, providing:
	 * - Binary compatibility: Header file changes don't affect compiled code
	 * - Compilation hiding: toml++ dependencies not exposed in header files
	 * - Exception safety: Automatic resource management
	 * - Performance optimization: Avoid header file including numerous dependencies
	 *
	 * Private implementation contains:
	 * - Document state flags (null status, validity flags)
	 * - Root table data (QTomlObject)
	 * - Internal caching and optimization data structures
	 *
	 * @note Uses std::unique_ptr for automatic memory management
	 * @note Enables binary compatibility across library versions
	 * @note Hides implementation details from client code
	 */
	std::unique_ptr<class QTomlDocumentPrivate> d_ptr;
};

/**
 * @brief Qt Meta-Object System registration for QTomlDocument.
 *
 * Registers QTomlDocument with Qt's type system, enabling use in QVariant
 * containers, signal/slot connections, and property systems. This registration
 * is essential for full integration with Qt's reflection and serialization systems.
 *
 * Enables:
 * - QVariant::fromValue<QTomlDocument>() and QVariant::value<QTomlDocument>()
 * - Signal/slot parameters using QTomlDocument
 * - Q_PROPERTY declarations with QTomlDocument
 * - Integration with Qt's debugging and logging systems
 * - Serialization through Qt's property system
 *
 * @note Registration occurs automatically during static initialization
 * @note Required for full Qt integration and QVariant support
 * @see QMetaType for more information about Qt's type system
 */
Q_DECLARE_METATYPE(QTomlDocument)