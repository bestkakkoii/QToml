/*
 * MIT License
 *
 * Copyright (c) 2025 QToml Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Project Information:
 * - Generated by: Claude 4.0 Sonnet (Anthropic AI) on 2025-08-30
 * - Verified and reviewed by: Bestkakkoii
 * - Original project structure and implementation concepts
 * - Built upon toml++ library (https://github.com/marzer/tomlplusplus)
 * - Qt framework integration and wrapper implementation
 */

#pragma once
#pragma execution_character_set("utf-8")

#include "qtomlvalue.h"

#include <QObject>
#include <QtGlobal>
#include <QStringList>
#include <QVariantMap>
#include <QHash>
#include <memory>
#include <initializer_list>

 /**
  * @class QTomlObject
  * @brief Encapsulates a TOML table (key-value pair collection) providing efficient hash table operations.
  *
  * QTomlObject represents a TOML table, which is an unordered collection of key-value pairs
  * according to the TOML v1.0.0 specification. It provides a Qt-style interface for
  * managing TOML table data with efficient hash-based lookups and modifications.
  *
  * The class follows Qt's container design patterns and maintains compatibility with
  * QHash while adding TOML-specific functionality. It uses the PIMPL pattern for
  * binary compatibility and efficient implementation hiding.
  *
  * Key features and capabilities:
  * - Unordered key-value storage matching TOML table semantics
  * - O(1) average-case lookup, insertion, and removal operations
  * - Support for all TOML key formats (bare, quoted, Unicode)
  * - Type-safe value storage through QTomlValue
  * - STL-style iterator interface for traversal
  * - Efficient memory management with capacity control
  * - Integration with Qt's variant system
  * - Exception-safe operations with strong guarantees
  *
  * TOML key format support:
  * - Bare keys: Letters, numbers, underscores, and hyphens
  * - Quoted keys: Any Unicode characters within quotes
  * - Dotted keys: Hierarchical key notation (handled externally)
  * - Case-sensitive key comparison as per TOML specification
  *
  * Performance characteristics:
  * - Average O(1) lookup, insertion, and removal
  * - Worst-case O(n) for hash collisions
  * - Memory usage scales linearly with element count
  * - Automatic load factor management
  * - Copy-on-write optimization for efficient copying
  *
  * Thread safety:
  * - Read operations are thread-safe when no modifications occur
  * - Write operations require external synchronization
  * - Iterator invalidation follows Qt container rules
  * - Copy construction is thread-safe with proper synchronization
  *
  * The interface design closely mirrors QJsonObject and QHash to provide
  * familiarity for Qt developers while adding TOML-specific optimizations
  * and compliance features.
  *
  * @note All keys are stored as QString objects supporting full Unicode
  * @note Values are stored as QTomlValue objects supporting all TOML types
  * @note The class maintains TOML specification compliance for key handling
  * @note Empty tables are valid TOML structures
  *
  * @example
  * @code
  * // Create and populate a TOML table
  * QTomlObject config;
  * config.insert("host", QTomlValue("localhost"));
  * config.insert("port", QTomlValue(8080));
  * config.insert("ssl", QTomlValue(true));
  *
  * // Query and modify values
  * if (config.contains("port")) {
  *     int port = config["port"].toInteger();
  *     config["port"] = QTomlValue(port + 1);
  * }
  *
  * // Iterate over key-value pairs
  * for (auto it = config.begin(); it != config.end(); ++it) {
  *     qDebug() << it.key() << "=" << it.value().toString();
  * }
  *
  * // Convert to Qt variant for integration
  * QVariantMap qtMap = config.toVariantMap();
  * @endcode
  *
  * @see QTomlValue for value type documentation
  * @see QTomlDocument for document-level operations
  * @see QTomlArray for array functionality
  * @see TOML tables specification at https://toml.io/en/v1.0.0#table
  */
class Q_CORE_EXPORT QTomlObject
{
	Q_GADGET
public:
	/**
	 * @brief Iterator type for mutable hash traversal.
	 *
	 * Provides mutable access to key-value pairs in the hash table.
	 * Based on QHash::iterator with the same semantics and capabilities.
	 */
	using iterator = QHash<QString, QTomlValue>::iterator;

	/**
	 * @brief Const iterator type for immutable hash traversal.
	 *
	 * Provides read-only access to key-value pairs in the hash table.
	 * Based on QHash::const_iterator with the same semantics and capabilities.
	 */
	using const_iterator = QHash<QString, QTomlValue>::const_iterator;

	/**
	 * @brief Default constructor creating an empty TOML table.
	 *
	 * Creates a QTomlObject instance with no key-value pairs. The table is ready
	 * for immediate use and can have elements added via insert() or operator[].
	 *
	 * This constructor is marked noexcept to guarantee no exceptions will be
	 * thrown during construction, making it safe for use in exception-sensitive
	 * contexts.
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for construction only; concurrent access requires external synchronization
	 *
	 * @example
	 * @code
	 * QTomlObject table;
	 * Q_ASSERT(table.isEmpty());
	 * Q_ASSERT(table.size() == 0);
	 * @endcode
	 */
	QTomlObject() noexcept;

	/**
	 * @brief Initializer list constructor for convenient table creation.
	 *
	 * Creates a QTomlObject instance initialized with the provided key-value pairs.
	 * This constructor enables brace-initialization syntax for creating tables
	 * with known content at compile time.
	 *
	 * The implementation pre-allocates memory for optimal performance, avoiding
	 * multiple reallocations during construction. Keys must be unique; duplicate
	 * keys will result in the last value overwriting previous ones.
	 *
	 * @param args Initializer list of key-value pairs to populate the table
	 *
	 * @complexity O(n) where n is the number of pairs in the initializer list
	 * @threadsafety Thread-safe for construction only
	 *
	 * @example
	 * @code
	 * QTomlObject config{
	 *     {"host", QTomlValue("localhost")},
	 *     {"port", QTomlValue(8080)},
	 *     {"ssl", QTomlValue(true)}
	 * };
	 * Q_ASSERT(config.size() == 3);
	 * Q_ASSERT(config["host"].toString() == "localhost");
	 * @endcode
	 *
	 * @note Pairs are copied into the table; original objects remain unchanged
	 * @note Duplicate keys result in last-value-wins behavior
	 */
	QTomlObject(std::initializer_list<std::pair<QString, QTomlValue>> args);

	/**
	 * @brief Copy constructor creating a deep copy of another table.
	 *
	 * Creates a new QTomlObject instance that is an independent copy of the
	 * provided table. All key-value pairs are deep-copied, ensuring modifications
	 * to either table do not affect the other.
	 *
	 * Uses the PIMPL pattern's copy semantics to ensure proper resource
	 * management and deep copying of all contained values.
	 *
	 * @param other The QTomlObject instance to copy
	 *
	 * @complexity O(n) where n is the number of key-value pairs in the source table
	 * @threadsafety Thread-safe for construction; the source table should not be modified during copying
	 *
	 * @example
	 * @code
	 * QTomlObject original{{"key1", QTomlValue(42)}, {"key2", QTomlValue("hello")}};
	 * QTomlObject copy(original);
	 *
	 * copy.insert("key3", QTomlValue(true));
	 * Q_ASSERT(original.size() == 2);  // Original unchanged
	 * Q_ASSERT(copy.size() == 3);      // Copy has new element
	 * @endcode
	 */
	QTomlObject(const QTomlObject& other);

	/**
	 * @brief Move constructor for efficient resource transfer.
	 *
	 * Creates a new QTomlObject instance by transferring ownership of resources
	 * from the source table. The source table becomes empty but remains in a
	 * valid state after the move.
	 *
	 * This constructor provides optimal performance for temporary tables and
	 * return value optimization scenarios.
	 *
	 * @param other Rvalue reference to the QTomlObject instance to move from
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for construction only
	 *
	 * @example
	 * @code
	 * QTomlObject createConfig() {
	 *     QTomlObject temp{{"version", QTomlValue("1.0")}, {"debug", QTomlValue(false)}};
	 *     return temp;  // Move constructor called automatically
	 * }
	 *
	 * QTomlObject config = createConfig();  // Efficient transfer
	 * @endcode
	 *
	 * @note Marked noexcept for optimal move semantics and exception safety
	 */
	QTomlObject(QTomlObject&& other) noexcept;

	/**
	 * @brief Destructor ensuring proper cleanup of resources.
	 *
	 * Automatically releases all resources associated with the table,
	 * including all contained key-value pairs. The PIMPL pattern ensures
	 * proper cleanup order and exception safety.
	 *
	 * @complexity O(n) where n is the number of elements requiring cleanup
	 * @threadsafety Thread-safe for destruction only
	 *
	 * @note Marked noexcept to guarantee no exceptions during destruction
	 * @note Uses RAII principles for automatic resource management
	 */
	~QTomlObject() noexcept;

	/**
	 * @brief Copy assignment operator for table replacement.
	 *
	 * Replaces the contents of this table with a deep copy of another table.
	 * Includes self-assignment protection to handle cases where a table
	 * is assigned to itself.
	 *
	 * All existing key-value pairs in this table are replaced with copies
	 * of pairs from the source table. The operation is exception-safe.
	 *
	 * @param other The QTomlObject instance to copy from
	 * @return Reference to this table for chaining operations
	 *
	 * @complexity O(n + m) where n is current size and m is source size
	 * @threadsafety Not thread-safe; external synchronization required for concurrent access
	 *
	 * @example
	 * @code
	 * QTomlObject table1{{"key1", QTomlValue(1)}};
	 * QTomlObject table2{{"key2", QTomlValue(2)}, {"key3", QTomlValue(3)}};
	 *
	 * table1 = table2;  // table1 now contains [key2=2, key3=3]
	 * Q_ASSERT(table1.size() == 2);
	 * @endcode
	 *
	 * @note Self-assignment (table = table) is handled safely
	 */
	QTomlObject& operator=(const QTomlObject& other);

	/**
	 * @brief Move assignment operator for efficient resource transfer.
	 *
	 * Replaces the contents of this table by transferring ownership from
	 * another table. The source table becomes empty but remains valid.
	 *
	 * This operation is highly efficient as it transfers resources rather
	 * than copying data, making it ideal for performance-critical scenarios.
	 *
	 * @param other Rvalue reference to the QTomlObject instance to move from
	 * @return Reference to this table for chaining operations
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject table1{{"key1", QTomlValue(1)}};
	 * QTomlObject table2{{"key2", QTomlValue(2)}, {"key3", QTomlValue(3)}};
	 *
	 * table1 = std::move(table2);  // Efficient transfer
	 * Q_ASSERT(table1.size() == 2);
	 * // table2 is now in valid but unspecified state
	 * @endcode
	 *
	 * @note Marked noexcept for optimal performance and exception safety
	 */
	QTomlObject& operator=(QTomlObject&& other) noexcept;

	// ==================== Capacity Management ====================

	/**
	 * @brief Reserves memory capacity for future key-value pairs.
	 *
	 * Pre-allocates memory to hold at least the specified number of key-value
	 * pairs without triggering reallocations. This is a performance optimization
	 * for scenarios where the approximate final size is known.
	 *
	 * If the current capacity is already greater than or equal to the requested
	 * size, this function has no effect. The reserve operation never reduces capacity.
	 *
	 * @param size The minimum number of key-value pairs to reserve space for
	 *
	 * @complexity O(n) if reallocation occurs, O(1) otherwise
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject config;
	 * config.reserve(1000);  // Pre-allocate for 1000 pairs
	 *
	 * // Now adding pairs will be efficient
	 * for (int i = 0; i < 1000; ++i) {
	 *     config.insert(QString("key%1").arg(i), QTomlValue(i));  // No reallocations
	 * }
	 * @endcode
	 *
	 * @note This function does not change the table size, only its capacity
	 * @see capacity(), size()
	 */
	void reserve(qsizetype size);

	/**
	 * @brief Returns the current memory capacity of the table.
	 *
	 * Returns the number of key-value pairs that can be stored in the currently
	 * allocated memory before a reallocation is required. This value is always
	 * greater than or equal to size().
	 *
	 * Understanding capacity is useful for performance optimization and memory
	 * usage analysis.
	 *
	 * @return The current capacity of the table
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject table;
	 * qDebug() << "Initial capacity:" << table.capacity();
	 *
	 * table.reserve(100);
	 * Q_ASSERT(table.capacity() >= 100);
	 * Q_ASSERT(table.size() == 0);  // Size unchanged
	 * @endcode
	 *
	 * @note Marked noexcept as it never throws exceptions
	 * @see reserve(), size()
	 */
	qsizetype capacity() const noexcept;

	// ==================== Element Modification ====================

	/**
	 * @brief Inserts a key-value pair into the table.
	 *
	 * Inserts the specified key-value pair into the table. If the key already
	 * exists, its value is replaced with the new value. The key and value are
	 * copied into the table.
	 *
	 * @param key The key to insert (QString)
	 * @param value The value to associate with the key
	 * @return Iterator pointing to the inserted or updated key-value pair
	 *
	 * @complexity O(1) average case, O(n) worst case if rehashing occurs
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject config;
	 * auto it = config.insert("database_host", QTomlValue("localhost"));
	 * Q_ASSERT(it.key() == "database_host");
	 * Q_ASSERT(it.value().toString() == "localhost");
	 * @endcode
	 *
	 * @see insert(const QString&, QTomlValue&&), insert(QString&&, QTomlValue&&)
	 */
	iterator insert(const QString& key, const QTomlValue& value);

	/**
	 * @brief Inserts a key-value pair using move semantics for the value.
	 *
	 * Inserts the specified key-value pair, moving the value to avoid copying.
	 * The key is copied, but the value is moved for efficiency. If the key
	 * already exists, its value is replaced.
	 *
	 * @param key The key to insert (copied)
	 * @param value The value to move into the table
	 * @return Iterator pointing to the inserted or updated key-value pair
	 *
	 * @complexity O(1) average case, O(n) worst case if rehashing occurs
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject config;
	 * config.insert("temp_data", QTomlValue(generateLargeArray()));  // Move from temporary
	 * @endcode
	 *
	 * @note More efficient than copy version for expensive-to-copy values
	 */
	iterator insert(const QString& key, QTomlValue&& value);

	/**
	 * @brief Inserts a key-value pair using move semantics for both.
	 *
	 * Inserts the specified key-value pair, moving both the key and value
	 * to avoid copying. This is the most efficient insertion method when
	 * both the key and value can be moved from.
	 *
	 * @param key The key to move into the table
	 * @param value The value to move into the table
	 * @return Iterator pointing to the inserted or updated key-value pair
	 *
	 * @complexity O(1) average case, O(n) worst case if rehashing occurs
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject config;
	 * QString dynamicKey = generateKey();
	 * config.insert(std::move(dynamicKey), QTomlValue(42));  // Move both
	 * @endcode
	 *
	 * @note Most efficient insertion method for movable key-value pairs
	 */
	iterator insert(QString&& key, QTomlValue&& value);

	/**
	 * @brief Removes a key and its associated value from the table.
	 *
	 * Removes the key-value pair with the specified key from the table.
	 * If the key does not exist, the operation has no effect and is safe.
	 *
	 * @param key The key of the pair to remove
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"temp", QTomlValue(123)}, {"keep", QTomlValue(456)}};
	 * config.remove("temp");
	 * Q_ASSERT(!config.contains("temp"));
	 * Q_ASSERT(config.contains("keep"));
	 * @endcode
	 *
	 * @note Safe to call with non-existent keys
	 * @see take() for removal with value retrieval
	 */
	void remove(const QString& key);

	/**
	 * @brief Removes a key and returns its associated value.
	 *
	 * Removes the key-value pair with the specified key from the table and
	 * returns the value. If the key does not exist, returns a default-constructed
	 * QTomlValue (Null type).
	 *
	 * @param key The key of the pair to remove and retrieve
	 * @return The value associated with the key, or Null if key doesn't exist
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"temp", QTomlValue(123)}};
	 * QTomlValue value = config.take("temp");
	 * Q_ASSERT(value.toInteger() == 123);
	 * Q_ASSERT(!config.contains("temp"));
	 *
	 * QTomlValue missing = config.take("nonexistent");
	 * Q_ASSERT(missing.isNull());
	 * @endcode
	 *
	 * @see remove() for removal without value retrieval
	 */
	QTomlValue take(const QString& key);

	// ==================== Element Queries ====================

	/**
	 * @brief Checks if the table contains a specific key.
	 *
	 * Tests whether the table contains a key-value pair with the specified key.
	 * This is an efficient way to check for key existence before accessing values.
	 *
	 * @param key The key to search for
	 * @return true if the key exists in the table, false otherwise
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"debug", QTomlValue(true)}};
	 * if (config.contains("debug")) {
	 *     bool debugMode = config["debug"].toBool();
	 * }
	 * @endcode
	 *
	 * @note Marked const as it doesn't modify the table
	 */
	bool contains(const QString& key) const;

	/**
	 * @brief Retrieves the value for a specific key.
	 *
	 * Returns the value associated with the specified key. If the key does not
	 * exist, returns a default-constructed QTomlValue (Null type).
	 *
	 * @param key The key to look up
	 * @return The value associated with the key, or Null if key doesn't exist
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"port", QTomlValue(8080)}};
	 * QTomlValue port = config.value("port");
	 * Q_ASSERT(port.toInteger() == 8080);
	 *
	 * QTomlValue missing = config.value("nonexistent");
	 * Q_ASSERT(missing.isNull());
	 * @endcode
	 *
	 * @note Returns a copy of the value, not a reference
	 * @see value(const QString&, const QTomlValue&) for default value support
	 */
	QTomlValue value(const QString& key) const;

	/**
	 * @brief Retrieves the value for a specific key with default fallback.
	 *
	 * Returns the value associated with the specified key. If the key does not
	 * exist, returns the provided default value instead of a Null value.
	 *
	 * @param key The key to look up
	 * @param defaultValue The value to return if the key doesn't exist
	 * @return The value associated with the key, or defaultValue if key doesn't exist
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"port", QTomlValue(8080)}};
	 *
	 * int port = config.value("port", QTomlValue(80)).toInteger();
	 * Q_ASSERT(port == 8080);  // Key exists, returns actual value
	 *
	 * int timeout = config.value("timeout", QTomlValue(30)).toInteger();
	 * Q_ASSERT(timeout == 30);  // Key missing, returns default
	 * @endcode
	 *
	 * @note Useful for providing sensible defaults for optional configuration
	 */
	QTomlValue value(const QString& key, const QTomlValue& defaultValue) const;

	/**
	 * @brief Returns a list of all keys in the table.
	 *
	 * Creates and returns a QStringList containing all keys currently stored
	 * in the table. The order of keys is not guaranteed as TOML tables are
	 * unordered collections.
	 *
	 * @return QStringList containing all keys in the table
	 *
	 * @complexity O(n) where n is the number of key-value pairs
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"host", QTomlValue("localhost")}, {"port", QTomlValue(8080)}};
	 * QStringList keys = config.keys();
	 * Q_ASSERT(keys.contains("host"));
	 * Q_ASSERT(keys.contains("port"));
	 * Q_ASSERT(keys.size() == 2);
	 * @endcode
	 *
	 * @note Order of keys is not guaranteed due to hash table nature
	 * @note Useful for iteration when key names are needed
	 */
	QStringList keys() const;

	// ==================== Find Methods ====================

	/**
	 * @brief Finds a key-value pair and returns a mutable iterator.
	 *
	 * Searches for the specified key and returns an iterator pointing to the
	 * key-value pair. If the key is not found, returns end().
	 *
	 * @param key The key to search for
	 * @return Iterator pointing to the found pair, or end() if not found
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Not thread-safe; external synchronization required for modifications
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"debug", QTomlValue(false)}};
	 * auto it = config.find("debug");
	 * if (it != config.end()) {
	 *     it.value() = QTomlValue(true);  // Modify through iterator
	 * }
	 * @endcode
	 *
	 * @note Marked noexcept for performance
	 * @see find(const QString&) const for read-only access
	 */
	iterator find(const QString& key) noexcept;

	/**
	 * @brief Finds a key-value pair and returns a const iterator.
	 *
	 * Searches for the specified key and returns a const iterator pointing to the
	 * key-value pair. If the key is not found, returns end().
	 *
	 * @param key The key to search for
	 * @return Const iterator pointing to the found pair, or end() if not found
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * const QTomlObject config{{"version", QTomlValue("1.0")}};
	 * auto it = config.find("version");
	 * if (it != config.end()) {
	 *     QString version = it.value().toString();
	 * }
	 * @endcode
	 *
	 * @note Marked noexcept for performance
	 * @note Provides read-only access to found elements
	 */
	const_iterator find(const QString& key) const noexcept;

	// ==================== Container Information ====================

	/**
	 * @brief Returns the number of key-value pairs in the table.
	 *
	 * Returns the current count of key-value pairs stored in the table.
	 * This value can range from 0 (empty table) to the maximum capacity
	 * supported by the underlying container.
	 *
	 * @return The number of key-value pairs currently in the table
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"key1", QTomlValue(1)}, {"key2", QTomlValue(2)}};
	 * Q_ASSERT(config.size() == 2);
	 *
	 * config.insert("key3", QTomlValue(3));
	 * Q_ASSERT(config.size() == 3);
	 * @endcode
	 *
	 * @note Marked noexcept as it never throws exceptions
	 * @see count(), isEmpty(), capacity()
	 */
	qsizetype size() const noexcept;

	/**
	 * @brief Returns the number of key-value pairs in the table (alias for size()).
	 *
	 * Provides an alternative name for size() to match Qt container conventions.
	 * This method returns exactly the same value as size().
	 *
	 * @return The number of key-value pairs currently in the table
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @note This is an alias for size() for API consistency with Qt containers
	 * @see size(), isEmpty()
	 */
	qsizetype count() const noexcept;

	/**
	 * @brief Checks whether the table contains no key-value pairs.
	 *
	 * Returns true if the table has no key-value pairs (size() == 0), false otherwise.
	 * This is more efficient and expressive than checking if size() equals zero.
	 *
	 * @return true if the table is empty, false if it contains pairs
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject table;
	 * Q_ASSERT(table.isEmpty());
	 *
	 * table.insert("key", QTomlValue(42));
	 * Q_ASSERT(!table.isEmpty());
	 * @endcode
	 *
	 * @note Marked noexcept as it never throws exceptions
	 * @see size(), count()
	 */
	bool isEmpty() const noexcept;

	// ==================== Subscript Operators ====================

	/**
	 * @brief Const subscript operator for read-only key access.
	 *
	 * Provides read-only access to the value associated with the specified key.
	 * If the key does not exist, returns a default-constructed QTomlValue (Null type).
	 * This operator does not modify the table.
	 *
	 * @param key The key to look up
	 * @return Copy of the value associated with the key, or Null if key doesn't exist
	 *
	 * @complexity O(1) average case, O(n) worst case
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * const QTomlObject config{{"port", QTomlValue(8080)}};
	 * int port = config["port"].toInteger();  // Safe read-only access
	 * QTomlValue missing = config["nonexistent"];  // Returns Null value
	 * @endcode
	 *
	 * @note Returns a copy, not a reference, for safety
	 * @note Does not create missing keys (unlike non-const version)
	 */
	QTomlValue operator[](const QString& key) const;

	/**
	 * @brief Mutable subscript operator for read-write key access.
	 *
	 * Provides mutable access to the value associated with the specified key.
	 * If the key does not exist, it is created with a default-constructed
	 * QTomlValue (Null type) and a reference to it is returned.
	 *
	 * @param key The key to access or create
	 * @return Reference to the value associated with the key
	 *
	 * @complexity O(1) average case, O(n) worst case if rehashing occurs
	 * @threadsafety Not thread-safe; external synchronization required
	 *
	 * @example
	 * @code
	 * QTomlObject config;
	 * config["host"] = QTomlValue("localhost");  // Creates key if missing
	 * config["port"] = QTomlValue(8080);
	 *
	 * config["port"] = QTomlValue(9090);  // Modifies existing value
	 * Q_ASSERT(config["port"].toInteger() == 9090);
	 * @endcode
	 *
	 * @note Creates missing keys with Null values
	 * @note Returns a reference allowing direct modification
	 * @warning May modify the table by creating missing keys
	 */
	QTomlValue& operator[](const QString& key);

	// ==================== Iterator Interface ====================

	/**
	 * @brief Returns a mutable iterator to the beginning of the table.
	 *
	 * Provides a mutable iterator pointing to the first key-value pair in the table.
	 * If the table is empty, this iterator equals end(). The order of iteration
	 * is not guaranteed due to the hash table nature.
	 *
	 * @return Mutable iterator to the first key-value pair
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Not thread-safe; external synchronization required for modifications
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"key1", QTomlValue(1)}, {"key2", QTomlValue(2)}};
	 *
	 * for (auto it = config.begin(); it != config.end(); ++it) {
	 *     // Modify values through iterator
	 *     it.value() = QTomlValue(it.value().toInteger() * 2);
	 * }
	 * @endcode
	 *
	 * @see end(), constBegin()
	 */
	iterator begin() noexcept;

	/**
	 * @brief Returns a const iterator to the beginning of the table.
	 *
	 * Provides a read-only iterator pointing to the first key-value pair in the table.
	 * If the table is empty, this iterator equals end().
	 *
	 * @return Const iterator to the first key-value pair
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * const QTomlObject config{{"key1", QTomlValue(1)}, {"key2", QTomlValue(2)}};
	 *
	 * for (auto it = config.begin(); it != config.end(); ++it) {
	 *     qDebug() << it.key() << "=" << it.value().toInteger();
	 * }
	 * @endcode
	 *
	 * @see end(), constBegin()
	 */
	const_iterator begin() const noexcept;

	/**
	 * @brief Returns a const iterator to the beginning of the table.
	 *
	 * Explicitly provides a read-only iterator pointing to the first key-value pair.
	 * This method is equivalent to begin() const but makes the const intent clear.
	 *
	 * @return Const iterator to the first key-value pair
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @see constEnd(), begin()
	 */
	const_iterator constBegin() const noexcept;

	/**
	 * @brief Returns a mutable iterator to one past the last key-value pair.
	 *
	 * Provides a mutable iterator pointing to the theoretical element following
	 * the last key-value pair. This iterator is used as the end marker for iteration
	 * and should not be dereferenced.
	 *
	 * @return Mutable iterator to one past the last key-value pair
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Not thread-safe; external synchronization required for modifications
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"key1", QTomlValue(1)}, {"key2", QTomlValue(2)}};
	 *
	 * // Standard iteration pattern
	 * for (auto it = config.begin(); it != config.end(); ++it) {
	 *     // Process each key-value pair
	 * }
	 * @endcode
	 *
	 * @warning Never dereference the end() iterator
	 * @see begin(), constEnd()
	 */
	iterator end() noexcept;

	/**
	 * @brief Returns a const iterator to one past the last key-value pair.
	 *
	 * Provides a read-only iterator pointing to the theoretical element following
	 * the last key-value pair. This iterator serves as the end marker for const iteration.
	 *
	 * @return Const iterator to one past the last key-value pair
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @see begin(), constEnd()
	 */
	const_iterator end() const noexcept;

	/**
	 * @brief Returns a const iterator to one past the last key-value pair.
	 *
	 * Explicitly provides a read-only iterator pointing to the end marker.
	 * This method is equivalent to end() const but makes the const intent clear.
	 *
	 * @return Const iterator to one past the last key-value pair
	 *
	 * @complexity O(1) - Constant time complexity
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @see constBegin(), end()
	 */
	const_iterator constEnd() const noexcept;

	// ==================== Type Conversion ====================

	/**
	 * @brief Converts the table to a QVariantMap for Qt integration.
	 *
	 * Creates a QVariantMap containing QVariant representations of all
	 * key-value pairs in the table. This enables integration with Qt's
	 * property system, QML, and other Qt APIs that work with QVariant.
	 *
	 * Each QTomlValue is converted to its corresponding QVariant representation
	 * using the QTomlValue::toVariant() method. Keys are preserved as QString objects.
	 *
	 * @return QVariantMap containing converted key-value pairs
	 *
	 * @complexity O(n) where n is the number of key-value pairs in the table
	 * @threadsafety Thread-safe for read-only access when table is not being modified
	 *
	 * @example
	 * @code
	 * QTomlObject config{{"host", QTomlValue("localhost")}, {"port", QTomlValue(8080)}, {"ssl", QTomlValue(true)}};
	 * QVariantMap variants = config.toVariantMap();
	 *
	 * Q_ASSERT(variants.size() == 3);
	 * Q_ASSERT(variants["host"].toString() == "localhost");
	 * Q_ASSERT(variants["port"].toInt() == 8080);
	 * Q_ASSERT(variants["ssl"].toBool() == true);
	 * @endcode
	 *
	 * @note All QTomlValue objects are converted to their QVariant equivalents
	 * @see fromVariantMap(), QTomlValue::toVariant()
	 */
	QVariantMap toVariantMap() const;

	/**
	 * @brief Creates a QTomlObject from a QVariantMap.
	 *
	 * Converts a QVariantMap to a QTomlObject by attempting to convert each
	 * QVariant to a QTomlValue. This is useful for integrating with Qt APIs
	 * that provide data as QVariant containers.
	 *
	 * Each QVariant in the map is converted using appropriate QTomlValue
	 * constructors or conversion methods. If a conversion fails, a
	 * default-constructed QTomlValue (Null) may be used.
	 *
	 * @param map The QVariantMap to convert
	 * @return QTomlObject containing the converted key-value pairs
	 *
	 * @complexity O(n) where n is the number of key-value pairs in the map
	 * @threadsafety Thread-safe (creates new instance)
	 *
	 * @example
	 * @code
	 * QVariantMap qtMap;
	 * qtMap["host"] = "localhost";
	 * qtMap["port"] = 8080;
	 * qtMap["ssl"] = true;
	 *
	 * QTomlObject config = QTomlObject::fromVariantMap(qtMap);
	 * Q_ASSERT(config.size() == 3);
	 * Q_ASSERT(config["host"].toString() == "localhost");
	 * @endcode
	 *
	 * @note Failed conversions may result in Null QTomlValue objects
	 * @note Not all QVariant types may be representable in TOML
	 * @see toVariantMap(), QTomlValue conversion constructors
	 */
	static QTomlObject fromVariantMap(const QVariantMap& map);

private:
	/**
	 * @brief PIMPL pattern private implementation pointer.
	 *
	 * Uses smart pointer to manage private implementation, providing:
	 * - Binary compatibility: Header file modifications don't affect compiled code
	 * - Compilation hiding: Implementation details not exposed in header files
	 * - Exception safety: Automatic resource management
	 * - Performance optimization: Avoids including numerous dependencies in header files
	 *
	 * The private implementation contains:
	 * - Hash table storage (QHash<QString, QTomlValue>)
	 * - Capacity management data
	 * - Performance optimization structures
	 */
	std::unique_ptr<class QTomlObjectPrivate> d_ptr;
};

Q_DECLARE_METATYPE(QTomlObject)